
Colors
Info
The color palette defines the core colors used across the product’s interface, providing a consistent and accessible visual identity. Each color is assigned a role to ensure clarity, readability, and alignment with the brand’s visual language.
Platforms Supported: Web, Mobile
Components Covered:
Primary Colors


Secondary Colors


Status Colors (Success, Warning, Disabled)


Base Colors


Gradients



Principles
Consistency: Colors must be applied uniformly across all components to strengthen brand recognition and create a seamless visual experience.


Simplicity: Focus on a limited set of colors to maintain a clean, professional interface without overwhelming users.


Accessibility: Color contrast should be sufficient to ensure readability, especially for key elements such as text, buttons, and alerts.


Hierarchy: Colors should support a clear visual hierarchy, guiding users toward important actions and making it easy to differentiate between primary, secondary, and less important elements.



Color Palette
Follow these principles to create legible and visually balanced typography. Use in conjunction with color and space tokens in product experiences.
Primary 500 - 


Primary 400


Primary 300


Primary 200


Primary 100


Secondary 500


Secondary 400


Secondary 300


Secondary 200


Secondary 100


Warning Primary


Warning Light


Success Primary


Success Light


Disable Dark


Disable Light


Base White


Base Black


Gradient



Color Roles
Color is used to reinforce the branding, theme of the brand and define content hierarchy. Color roles describe the intention behind the color. For example, color roles are applied to buttons to differentiate between primary, secondary, warning, or dangerous actions.
Color Code
Role
Description
#0C0F24
Primary 500
Use for all the primary Call to Action items like buttons and links mostly that communicate the brand
#3D3F50
Primary 400
Use for all the primary Call to Action items like buttons and links mostly that communicate the brand
#858791
Primary 300
Use for all the disabled CTAs, background for cards
#1B489B
Secondary 500
Use for all types of texts, can be used for cards too
#496DAF
Secondary 400
Use for all the Headlines, body text, can be used for cards too
#93A3CB
Secondary 300
Use for all the Headlines, body text, can be used for cards too
#895D0B
Warning
Use for all the warning and error states, messages, tags or pop up illustrations
#FFE1A4
Warning Light
Use for all the warning and error states, messages, tags or pop up illustrations
#1E774A
Success
Use for all the success states, messages, tags or pop up illustrations showing success
#CCF2DB
Success Light
Use for all the success states, messages, tags or pop up illustrations showing success
#858791
Disabled
Description
#FFFFFF
Base
A neutral background color used for card backgrounds or areas where content needs to stand out
#303030
Base
A darker base color for text and essential elements requiring contrast with lighter backgrounds
#496DAF
Hover State
Whenever hovered over the primary filled button, CTA should change to this hover state
#3D3F50(15%)<br/>-#858791(100%)
Gradient
Use for showcasing the selection Menu option in Web


Color Usage
Color is used to reinforce the branding, theme of the brand and define content hierarchy. Color roles describe the intention behind the color. For example, color roles are applied to buttons to differentiate between primary, secondary, warning, or dangerous actions.
Primary Colors:


Primary (#0C0F24): Brand’s dominant color, used for key elements like CTAs, active states, and links.


Hover State (#3D3F50): Slightly lighter for hover effects on buttons/links.


Secondary Colors:


Secondary (#1B489B): Primary color for text, headlines, secondary elements (borders/icons).


Status Colors:


Success (#1E774A): Represents success states, confirmation dialogs, banners, or success alerts.


Warning (#895D0B): Error/warning notifications.


Base Colors:


Base Light (#FFFFFF): Backgrounds like cards, containers.


Base Dark (#303030): Essential text/UI elements that need contrast.



Design Guidelines
Contrast & Readability:
 Ensure sufficient contrast between text and background colors to enhance readability, especially for important content or call-to-action buttons.


Consistency:
 Use the colors consistently across all elements and pages, reinforcing the brand identity and helping users easily recognize actions or elements across different parts of the product.


Accessibility:
 Consider accessibility when choosing color combinations, ensuring the interface is usable for individuals with visual impairments. This includes maintaining high contrast between background and text or interactive elements.




Typography
Info
Typography plays a key role in establishing a clear visual hierarchy, ensuring readability, and maintaining consistency across the product. The design system defines typography guidelines for both web and mobile platforms to ensure that text remains legible, visually balanced, and in line with the overall brand.
Platforms Supported: Web, Mobile
Components Covered:
Headings


Body Text


Labels & Captions



Principles
Legibility: Ensure that text is easy to read at all sizes, across devices and screen resolutions. Font sizes, line heights, and spacing should be chosen to optimize readability.


Hierarchy: Establish a clear visual hierarchy by using different font sizes, weights, and spacing to guide users' attention through the content.


Consistency: Use consistent typography styles across all platforms, maintaining uniformity in font sizes, weights, and line heights across web and mobile.


Scalability: Typography should scale fluidly across different screen sizes, ensuring that content remains readable on both large desktop monitors and small mobile devices.



Web Typography
Name
Weight 01
Weight 02
Font Size
Line Height
Letter Spacing
Heading 01
Regular
Semi Bold
32px / 2rem
38px / 1.188em
0
Heading 02
Regular
Semi Bold
28px / 1.75rem
34px / 1.750em
0
Heading 03
Regular
Semi Bold
24px / 1.5rem
30px
0
Heading 04
Regular
Semi Bold
20px / 1.25rem
24px
0
Body
Regular
Semi Bold
16px / 1rem
Line Height
0
Caption/Note
Regular
Semi Bold
14px / 0.875rem
Line Height
0
Label/Info
Regular
Semi Bold
12px / 0.75rem
Line Height
0


Mobile Typography
Name
Font Weight
Font Weight
Font Size
Line Height
Letter Spacing
Heading 01
Regular
Semi Bold
28px / 1.75rem
34px / 1.750em
0
Heading 02
Regular
Semi Bold
24px / 1.5rem
30px
0
Heading 03
Regular
Semi Bold
20px / 1.25rem
24px
0
Heading 04
Regular
Semi Bold
18px / 1.25rem
Line Height
0
Body
Regular
Semi Bold
16px / 1rem
Line Height
0
Body 02
Regular
Semi Bold
14px / 0.875rem
Line Height
0
Caption/Note/Tags
Regular
Semi Bold
12px / 0.75rem
Line Height
0
Label
Regular
Semi Bold
10px / 0.50rem
Line Height
0


Usage
Web Typography:
Headings: Use larger font sizes for headings to create a strong hierarchy. Heading 01 is ideal for main titles, Heading 02 for section titles, and Heading 03 or Heading 04 for subheadings.


Body Text: Body text should remain legible and appropriately spaced, ensuring comfortable reading for longer paragraphs. Body 01 is for primary content, while Body 02 and Body 03 can be used for secondary or supporting text.


Captions/Labels: These are used for smaller, less prominent text like captions, field labels, and fine print.


Mobile Typography:
Headings: Mobile typography scales down slightly to accommodate smaller screen sizes. Use Heading 01 for main headings and Heading 02, 03, and 04 for subsections.


Body Text: Body 01 and Body 02 are used for all the body text, especially content-heavy sections, ensuring text remains legible on mobile devices.


Captions/Labels: Smaller text elements like captions, labels, notes are to be scaled down for mobile, ensuring they’re readable without taking up too much space.
Iconography
1. Info
Definition: Explains the purpose of icons and which platforms are supported.


Components Covered: Lists Action, Navigation, and Status/Notification icons.


2. Principles
Simplicity, consistency, scalability, accessibility—each with a brief description.


3. Icon Family
Visual Grid: Shows your entire icon set, grouped and clearly displayed.


4. Anatomy
Icon Structure: Details on sizing, stroke weight, and padding.


Icon Categories: Defines action, navigation, and status/notification icons.


5. Usage
Detailed usage guidance for action, navigation, and notification/status icons.


Notes on placement, feedback, orientation, variations (filled vs outlined), responsive behavior.


6. Best Practices
Covers scaling, testing, interactive states.


7. Dos & Don’ts
Provides a checklist for do’s (clarity, feedback, accessibility) and don’ts (over-complication, ambiguity, overloading).
Grid System Overview
1. Info
Explains the purpose of grids: structuring and organizing layouts, creating harmony and alignment, supporting responsive design, and ensuring consistency.



2. Principles
Consistency: Uniform spacing and proportion for a cohesive look.


Flexibility: Can adapt to various content types and screen sizes.


Clarity: Helps users scan content by providing visual anchors.


Balance: Distributes content evenly—no overcrowded areas.


Responsiveness: Layouts scale smoothly across device sizes.



3. Anatomy
Desktop Grid Example:


12 columns (common standard)


Column width: 72px


Gutters: 24px


Margins: 32px


Header: 80px height


Left nav: 248px wide


Container: 1192px wide


Mobile Grid Example:


4 columns


Margins: 16px or 10% (example uses % for margins)


Header/Bottom nav: 88px high


Visuals clearly show columns, gutters, margins, header/footer heights, and how the grid overlays UIs.



4. Usage
Columns & Flexibility: Use 12-column grids for desktop, 4-column for mobile, 8-column for tablet. Columns can stack or align based on screen size.


Gutter Sizes: Keep gutter sizes consistent; smaller on mobile, wider on desktop.


Responsive Breakpoints:


Mobile: 4 columns


Tablet: 8 columns


Desktop: 12 columns


Vertical Rhythm: Maintain consistent vertical spacing.


Content Alignment: Use columns/rows for aligning all elements.


Whitespace: Leave space around grid edges for breathing room and focus.

Illustrations Section Overview
1. Info
Purpose:


Enhance user experience with storytelling and context.


Used for onboarding, empty states, feedback, and to make the UI feel relatable.


Platforms: Web, Mobile


Components Covered:


Security/Status illustrations


Object illustrations (Location, Download, Mail, etc.)


Iconographic illustrations



2. Principles
Clarity: Illustrations should be clear, simple, and relevant—never overwhelming.


Consistency: Maintain uniform style, line weight, palette, and detail level for a cohesive look.


Engagement: Add personality to make the interface enjoyable and memorable.


Accessibility: Ensure good contrast and clear shapes for legibility.



3. Illustration Family
Shows a set of illustrations covering:


Security, Location, Download, Text, Search, Mail, Reports, No Internet, Warning, Success, Verified, etc.


Each illustration is paired with a descriptive label—consider doing the same in your Figma system for discoverability and documentation.



4. Meeples
Small illustrated avatars or tokens, e.g., for users or contributors. (Great for a “lovable” system—feel free to make these playful or brand-appropriate.)



5. Anatomy
Style:


Flat or semi-flat with soft, neutral tones—modern and approachable.


Use subtle gradients/shadows for depth, but avoid heavy details.


Color Palette:


Stick to your brand colors, primarily (e.g., blues, grays), plus a few accent colors for important elements.


Consistency:


Uniform stroke weights and visual approach for all illustrations.


Categories:


Status/Feedback: For alerts, success, error, etc.


Object/Action: Location, Download, Reports—useful for UI features.


Task/Concept: More abstract or high-level concepts like “No Data,” “No Search Results,” etc.



6. Usage
Status Illustrations:


Used in modals, alerts, and notifications for feedback on system state (success, warning, error, etc.).


Object/Action Illustrations:


Used in banners, empty states, or to clarify sections/features.


Concept Illustrations:


Used in onboarding, education, or guidance (“No Data Available,” “No Internet,” etc.).


Responsive Behavior:


Should scale to different screen sizes, maintaining legibility and balance.


Mobile: Ensure illustrations are tappable/touch-friendly when interactive.



7. Example Screens
Shows real screens with illustrations in context:


Status modal in mobile


Success notification overlay on desktop


Empty state in web dashboard


This is a great way to document illustration usage in your Figma system:
Show illustrations on UI mockups (desktop, mobile, tablet)


Add annotations explaining when and why each is used



8. Microcopy
Include succinct guidance near illustrations—e.g., for empty states, status, or onboarding.


Helps communicate intended user action or information.
Tags

Code:

import React from "react";
import clsx from "clsx";

// Status and Mode types
type Status = "default" | "primary" | "warning" | "success";
type Mode = "light" | "dark";
type Size = "tiny" | "base" | "large";

export interface LovableTagProps {
  label: string;
  status?: Status;
  mode?: Mode;
  size?: Size;
  iconLeft?: React.ReactNode;
  onClose?: () => void;
  className?: string;
}

const COLORS = {
  default: {
    light: {
      bg: "bg-[#E9ECF4]",
      text: "text-[#3D3F50]",
      icon: "text-[#3D3F50]",
      close: "text-[#3D3F50]",
    },
    dark: {
      bg: "bg-[#3D3F50]",
      text: "text-[#E9ECF4]",
      icon: "text-[#E9ECF4]",
      close: "text-[#E9ECF4]",
    },
  },
  primary: {
    light: {
      bg: "bg-[#D4DAEA]",
      text: "text-[#0C0F24]",
      icon: "text-[#0C0F24]",
      close: "text-[#3D3F50]",
    },
    dark: {
      bg: "bg-[#0C0F24]",
      text: "text-[#E9ECF4]",
      icon: "text-[#E9ECF4]",
      close: "text-[#E9ECF4]",
    },
  },
  warning: {
    light: {
      bg: "bg-[#FFE1A4]",
      text: "text-[#895D0B]",
      icon: "text-[#895D0B]",
      close: "text-[#895D0B]",
    },
    dark: {
      bg: "bg-[#895D0B]",
      text: "text-[#FFE1A4]",
      icon: "text-[#FFE1A4]",
      close: "text-[#FFE1A4]",
    },
  },
  success: {
    light: {
      bg: "bg-[#CCF2DB]",
      text: "text-[#1E774A]",
      icon: "text-[#1E774A]",
      close: "text-[#1E774A]",
    },
    dark: {
      bg: "bg-[#1E774A]",
      text: "text-[#CCF2DB]",
      icon: "text-[#CCF2DB]",
      close: "text-[#CCF2DB]",
    },
  },
};

const SIZES = {
  tiny: "text-[12px] h-[22px] min-w-[48px] px-[6px] gap-1 rounded-md leading-[18px]",
  base: "text-[14px] h-[24px] min-w-[56px] px-[6px] gap-1 rounded-md leading-[20px]",
  large: "text-[16px] h-[32px] min-w-[68px] px-[8px] gap-1 rounded-md leading-[24px]",
};

const ICON_SIZE = {
  tiny: 12,
  base: 14,
  large: 16,
};

export const LovableTag: React.FC<LovableTagProps> = ({
  label,
  status = "default",
  mode = "light",
  size = "base",
  iconLeft,
  onClose,
  className,
}) => {
  const color = COLORS[status][mode];
  const iconSize = ICON_SIZE[size];

  return (
    <span
      className={clsx(
        "inline-flex items-center font-['Roboto'] font-normal",
        SIZES[size],
        color.bg,
        color.text,
        className
      )}
      style={{ userSelect: "none" }}
    >
      {/* Left Icon (User icon fallback) */}
      <span className={clsx("flex items-center", color.icon)}>
        {iconLeft ?? (
          <svg width={iconSize} height={iconSize} fill="none" viewBox="0 0 16 16">
            <circle
              cx="8"
              cy={iconSize === 12 ? 4 : 5}
              r={iconSize === 12 ? 2.5 : 3.5}
              stroke="currentColor"
              strokeWidth={iconSize === 12 ? 0.75 : 1}
            />
            <path
              d={
                iconSize === 12
                  ? "M2.5 10.5C2.5 8.567 5.333 8.567 8 8.567C10.667 8.567 13.5 8.567 13.5 10.5"
                  : "M2 13C2 10.333 5.333 10.333 8 10.333C10.667 10.333 14 10.333 14 13"
              }
              stroke="currentColor"
              strokeWidth={iconSize === 12 ? 0.75 : 1}
              strokeLinecap="round"
            />
          </svg>
        )}
      </span>
      {/* Label */}
      <span className="mx-1">{label}</span>
      {/* Close (X) */}
      {onClose && (
        <button
          className={clsx("flex items-center px-0", color.close)}
          tabIndex={0}
          style={{
            width: iconSize,
            height: iconSize,
            background: "transparent",
            border: "none",
          }}
          aria-label="Remove tag"
          onClick={onClose}
        >
          {/* X Icon */}
          <svg width={iconSize} height={iconSize} viewBox="0 0 16 16" fill="none">
            <line
              x1="4"
              y1="4"
              x2="12"
              y2="12"
              stroke="currentColor"
              strokeWidth={iconSize === 12 ? 1.2 : 1.6}
              strokeLinecap="round"
            />
            <line
              x1="12"
              y1="4"
              x2="4"
              y2="12"
              stroke="currentColor"
              strokeWidth={iconSize === 12 ? 1.2 : 1.6}
              strokeLinecap="round"
            />
          </svg>
        </button>
      )}
    </span>
  );
};

Usage

<LovableTag label="Label" />
<LovableTag label="Label" status="primary" size="large" mode="dark" />
<LovableTag label="Label" status="warning" size="tiny" onClose={() => alert("Removed!")} />
<LovableTag label="Label" status="success" size="base" mode="dark" />


Info
Purpose:
 Tags categorize, label, or provide quick context about specific content/actions.


Organize content


Notify users


Draw attention to important info/status



Principles
Clarity: Immediate understanding of tag purpose/status.


Consistency: Color, typography, design are uniform across all variants.


Accessibility: Legible, interactive, meets accessibility standards.


Minimalism: Simple—no excess icons or decorative clutter.


Actionable Feedback: Interactive tags have clear feedback (hover, focus).



Tag Variants
Tags come in multiple variants and states, each with distinct color coding:
Default/Info: Neutral (gray, blue) for general info.


Update: Light blue/lavender for pending changes, updates, or attention.


Warning: Yellow/orange for deadlines, warnings, urgent tasks.


Success: Green for completion or positive outcomes.


Error: Red or dark orange for errors, failures, or irreversible actions.



Sizes & Anatomy
Sizes:


Tiny, Base, Large (with specific paddings and spacing for each)


Specs (Base example):


Alignment: Middle center


Vertical resizing: Hug


Horizontal resizing: Hug


Item spacing: 4


Padding (top/bottom): 2


Padding (left/right): 6


Each tag is a horizontal container with text, optional icon or close “x” button.



Usage Guidance
When and why to use each tag:
Default Tag:


For standard, neutral info/categorization.


Update Tag:


Draws attention to something needing review or update.


Warning Tag:


Highlights urgent or deadline-related items.


Success Tag:


Shows completion or positive state.


Error Tag:


Flags errors, failures, or critical issues.


Examples in context (screenshots):


Mobile & web UIs show tags in notification lists and status alerts.



Best Practices for Lovable Figma Design System
Variants:


Use Figma Variants for color (status), size, and optional close (“x”) actions.


Auto Layout:


Make tags resizable, so text length adjusts naturally.


Tokens:


Use design tokens for color/background/border, so updates are global and scalable.


Accessibility:


Check contrast, font size, focus states.


Documentation:


Include usage notes for each variant—when, why, and examples.


Microcopy:


Keep tag text short, clear, actionable.



Figma Setup Suggestions
Component Set:


Main tag (with/without close “x”), all color variants, all sizes.


Naming:


Tag / [Status] / [Size] / [With Close]


Properties:


Status (info, update, warning, success, error)


Size (tiny, base, large)


Dismissible (boolean)


Assets Panel:


Organize for quick drag-and-drop.

Tabs

Tab Code:

import React from "react";
import clsx from "clsx";

type Tab = {
  label: string;
};

interface LovableTabsProps {
  tabs: Tab[];
  activeIndex: number;
  onChange: (idx: number) => void;
}

export const LovableTabs: React.FC<LovableTabsProps> = ({
  tabs,
  activeIndex,
  onChange,
}) => {
  return (
    <div className="flex gap-6 border-b border-[#E7E7E9] bg-white w-fit">
      {tabs.map((tab, idx) => (
        <button
          key={tab.label}
          className={clsx(
            "flex items-center justify-center font-['Roboto'] font-semibold text-[16px] h-12 min-w-[76px] px-0 transition-colors border-b-2",
            idx === activeIndex
              ? "text-[#1B489B] border-[#1B489B]"
              : "text-[#3D3F50] border-transparent"
          )}
          style={{ outline: "none" }}
          onClick={() => onChange(idx)}
          tabIndex={0}
        >
          {tab.label}
        </button>
      ))}
    </div>
  );
};

Usage
const [activeTab, setActiveTab] = React.useState(0);

<LovableTabs
  tabs={[
    { label: "Tab Active" },
    { label: "Tab Inactive" },
    { label: "Tab Inactive" }
  ]}
  activeIndex={activeTab}
  onChange={setActiveTab}
/>


Rounded Corner Tab

import React, { useState } from "react";

// Tab data can be dynamic
const tabList = [
  { label: "Tab Active" },
  { label: "Tab Inactive" },
  { label: "Tab Inactive" }
];

export default function LovableTabs() {
  const [active, setActive] = useState(0);

  return (
    <div className="flex flex-col items-start p-0.5 gap-2.5 w-[318px] h-9 bg-[#E9ECF4] rounded-[54px]">
      <div className="flex flex-row items-center w-[314px] h-8">
        {tabList.map((tab, idx) => (
          <button
            key={tab.label + idx}
            className={`
              flex flex-row justify-center items-center gap-2.5
              px-4 py-1.5
              h-8
              font-['Roboto'] font-semibold text-[14px] leading-5
              transition-all
              ${
                active === idx
                  ? "bg-white rounded-[73px] text-[#1B489B]"
                  : "bg-transparent rounded-[31px] text-[#3D3F50]"
              }
            `}
            style={{
              width: idx === 0 ? 98 : 108
            }}
            onClick={() => setActive(idx)}
            aria-selected={active === idx}
            tabIndex={0}
            role="tab"
          >
            {tab.label}
          </button>
        ))}
      </div>
    </div>
  );
}





Info
Tabs let users switch between different views or sections within the same context. They keep content organized and quickly accessible, making navigation seamless on both desktop and mobile.

Principles
Clarity: Clearly show which tab is active.


Feedback: Use visual cues for active/inactive/hover/focus states.


Consistency: Keep style/placement uniform throughout the UI.


Hierarchy: Use tabs for top-level groupings.


Responsiveness: Adapt size/layout across screen sizes.



Anatomy
Tab Container: Holds all tabs, horizontal layout with equal spacing.


Active Tab: The selected tab—visually distinct (bold, underline, filled, or colored).


Inactive Tab: Available, but less prominent (lighter/muted).


Underline (optional): Extra visual cue for active tab.


Hover/Focus States: Indicate interactivity and accessibility.



Usage
Active Tab
Purpose: Shows current section/view.


When: When switching between related views.


Style: Bold, filled, colored, or underlined for prominence.


Inactive Tab
Purpose: Shows other available sections.


When: Next to active tab for navigation.


Style: Muted/lighter, no underline, no bold.


States
Hover: Slight color or border change.


Focus: Visible outline/border for keyboard nav.


Alignment
Left-aligned: Default, for most use cases.


Centered: For few tabs or balanced look, often on mobile.



Figma Implementation Best Practices
Variants:


State: Active, inactive, hover, focus


Underline: On/Off


Alignment: Left, centered (if needed)


Auto Layout:


Ensure tabs are equally spaced and can adapt to label length.


Design Tokens:


Use tokens for colors (active/inactive/hover/focus), spacing, and border/underline.


Accessibility:


Sufficient color contrast for all states.


Keyboard focus ring always visible.


Naming:


Tab / [State] / [Underline]


Documentation:


Include usage scenarios, alignment options, and interaction guidance in your Figma library.
Buttons – Lovable Design System

Code

import React from "react";
import clsx from "clsx";

type ButtonSize = "small" | "base" | "large";
type ButtonVariant = "solid" | "outline" | "ghost";
type ButtonColor = "primary" | "secondary";
type ButtonState = "default" | "hover" | "disabled";

interface LovableButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  size?: ButtonSize;
  variant?: ButtonVariant;
  color?: ButtonColor;
  iconLeft?: React.ReactNode;
  iconRight?: React.ReactNode;
  loading?: boolean;
  children?: React.ReactNode;
}

export const LovableButton: React.FC<LovableButtonProps> = ({
  size = "base",
  variant = "solid",
  color = "primary",
  iconLeft,
  iconRight,
  loading,
  disabled,
  children,
  ...props
}) => {
  // Color map
  const COLOR = {
    primary: {
      solid: "bg-[#1B489B] text-white",
      solidHover: "bg-gradient-to-r from-[#0C2B64] to-[#1B489B] text-white",
      outline: "border border-[#1B489B] text-[#1B489B] bg-transparent",
      outlineHover: "border border-[#1B489B] bg-[#E9ECF4] text-[#1B489B]",
      ghost: "bg-transparent text-[#1B489B]",
      ghostHover: "border border-[#D4DAEA] text-[#1B489B] bg-transparent",
      disabled: "bg-[#93A3CB] text-white opacity-50 cursor-not-allowed",
      outlineDisabled: "border border-[#93A3CB] text-[#93A3CB] bg-transparent opacity-50 cursor-not-allowed",
      ghostDisabled: "text-[#93A3CB] bg-transparent opacity-50 cursor-not-allowed",
    },
    secondary: {
      solid: "bg-[#3D3F50] text-white",
      solidHover: "bg-gradient-to-r from-[#3D3F50] via-[#858791] to-[#858791] text-white",
      outline: "border border-[#3D3F50] text-[#3D3F50] bg-transparent",
      outlineHover: "border border-[#3D3F50] bg-[#E7E7E9] text-[#3D3F50]",
      ghost: "bg-transparent text-[#3D3F50]",
      ghostHover: "border border-[#CECFD3] text-[#3D3F50] bg-transparent",
      disabled: "bg-[#858791] text-white opacity-50 cursor-not-allowed",
      outlineDisabled: "border border-[#858791] text-[#858791] bg-transparent opacity-50 cursor-not-allowed",
      ghostDisabled: "text-[#858791] bg-transparent opacity-50 cursor-not-allowed",
    },
  };

  // Size map
  const SIZE = {
    small: "h-8 min-w-[80px] px-3 text-sm rounded-lg gap-1.5",
    base: "h-10 min-w-[120px] px-4 text-base rounded-lg gap-2",
    large: "h-14 min-w-[160px] px-8 text-lg rounded-lg gap-3",
  };

  // Stateful color styles
  let baseStyle = "";
  if (disabled) {
    if (variant === "solid") {
      baseStyle = COLOR[color].disabled;
    } else if (variant === "outline") {
      baseStyle = COLOR[color].outlineDisabled;
    } else {
      baseStyle = COLOR[color].ghostDisabled;
    }
  } else {
    if (variant === "solid") {
      baseStyle = COLOR[color].solid + " hover:" + COLOR[color].solidHover;
    } else if (variant === "outline") {
      baseStyle = COLOR[color].outline + " hover:" + COLOR[color].outlineHover;
    } else {
      baseStyle = COLOR[color].ghost + " hover:" + COLOR[color].ghostHover;
    }
  }

  return (
    <button
      type="button"
      className={clsx(
        "flex items-center justify-center font-['Roboto'] font-normal select-none transition-all duration-150",
        SIZE[size],
        baseStyle,
        disabled && "pointer-events-none"
      )}
      aria-disabled={disabled}
      disabled={disabled}
      {...props}
    >
      {iconLeft && <span className="mr-2 flex items-center">{iconLeft}</span>}
      <span className="flex items-center">{children}</span>
      {iconRight && <span className="ml-2 flex items-center">{iconRight}</span>}
    </button>
  );
};

Usage

// Example icon
import { ArrowRight } from "lucide-react"; // or any icon library

<LovableButton
  size="large"
  variant="solid"
  color="primary"
  iconRight={<ArrowRight size={24} />}
>
  Button
</LovableButton>


Info
Buttons are essential for triggering actions and navigating users through the interface. They must be clear, accessible, and visually consistent.

Principles
Clarity: Instantly communicate their purpose (e.g., Submit, Save, Cancel).


Consistency: All variants follow platform-wide color, shape, and typography guidelines.


Accessibility: High contrast, legible text, accessible with keyboard/screen readers.


Minimalism: Avoid clutter; only use icons/text that help clarify action.


Feedback: Show visual changes on hover, active, and disabled states.



Types & Variants
Primary: Main action on a screen. Highest emphasis.


Secondary: Supporting actions, lower emphasis than primary.


Tertiary: Lowest emphasis, often text-only or minimal styling.


States:
Default


Hover


Active


Disabled


Loading


Sizes:
Large


Base


Small


Icon Options:
Icon left


Icon right


Icon only



Anatomy (with Figma specifics)
Container: Uses Auto Layout (horizontal), paddings per size.


Label: Text style matches typography tokens for buttons.


Icon (optional): 20x20 or 16x16 px, aligned with text.


Spacing:


Large: Padding 0 24px, Height 48px


Base: Padding 0 16px, Height 40px


Small: Padding 0 12px, Height 32px



Best Practices in Figma
Variants: Use Figma component properties for Type, State, Size, and Icon.


Auto Layout: Make buttons responsive to label length; maintain vertical/horizontal centering.


Naming Convention:
 Button / [Type] / [Size] / [State] / [Icon]


Design Tokens: Use color tokens for background, border, and text, plus spacing and radius tokens.


Accessibility:


Contrast: At least 4.5:1 for text


Focus ring: Visible on keyboard navigation


Label: Clear, never just an icon unless universally understood



Usage Guidelines
Primary Button
Purpose: The main call-to-action.


Style: Filled background, bold label.


Placement: Use one primary button per group/section.


Secondary Button
Purpose: Alternative or supporting actions.


Style: Outlined or subtle background, less emphasis.


Placement: For secondary choices like “Cancel”, “Learn More”.


Tertiary Button
Purpose: Low priority actions (e.g., “Cancel” or links).


Style: Text-only, minimal or ghost styling.



Interaction States
Hover: Slight color or shadow change.


Active: Slightly darker or pressed effect.


Disabled: Reduced opacity, not clickable.


Loading: Spinner replaces label/icon; button disabled.



Accessibility Tips
Always support keyboard and screen reader navigation.


Never use color alone to indicate state.


Always include accessible labels for icon-only buttons.
Checkbox – Lovable Design System

Code
import React from "react";

const STATES = [
  { state: "default", label: "Checkbox" },
  { state: "intermediate", label: "Checkbox" },
  { state: "checked", label: "Checkbox" },
  { state: "disabled", label: "Checkbox" },
  { state: "checkedDisabled", label: "Checkbox" },
];

const MODES = ["light", "dark"];

function getCheckboxStyles(state, mode) {
  // Returns icon + box styles per state and mode
  if (state === "default")
    return {
      box: `
        border ${mode === "light" ? "border-[#0C0F24]" : "border-white"}
        bg-transparent
      `,
      check: "hidden",
      indeterminate: "hidden",
      icon: "",
    };
  if (state === "intermediate")
    return {
      box: `
        ${mode === "light" ? "bg-[#1B489B]" : "bg-white"}
        border-transparent
      `,
      check: "hidden",
      indeterminate: `
        absolute w-[10px] h-[2px] rounded-[5px]
        left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2
        ${mode === "light" ? "bg-white" : "bg-[#0C0F24]"}
      `,
      icon: "",
    };
  if (state === "checked")
    return {
      box: `
        ${mode === "light" ? "bg-[#1B489B]" : "bg-white"}
        border-transparent
      `,
      check: `
        absolute w-[10px] h-[8px] left-1/2 top-1/2
        -translate-x-1/2 -translate-y-1/2
        ${mode === "light" ? "bg-white" : "bg-[#0C0F24]"}
        rounded
      `,
      indeterminate: "hidden",
      icon: "",
    };
  if (state === "disabled")
    return {
      box: `
        border ${mode === "light" ? "border-[#CECFD3]" : "border-[#58595B]"}
        bg-transparent
      `,
      check: "hidden",
      indeterminate: "hidden",
      icon: "",
    };
  if (state === "checkedDisabled")
    return {
      box: `
        ${mode === "light" ? "bg-[#D4DAEA]" : "bg-[#CECFD3]"}
        border-transparent
      `,
      check: `
        absolute w-[10px] h-[8px] left-1/2 top-1/2
        -translate-x-1/2 -translate-y-1/2
        ${mode === "light" ? "bg-white" : "bg-[#858791]"}
        rounded
      `,
      indeterminate: "hidden",
      icon: "",
    };
  return {};
}

function getTextStyles(state, mode) {
  if (state === "default")
    return mode === "light"
      ? "text-[#0C0F24]"
      : "text-white";
  if (state === "intermediate" || state === "checked")
    return mode === "light"
      ? "text-[#303030]"
      : "text-white";
  if (state === "disabled")
    return mode === "light"
      ? "text-[#858791]"
      : "text-[#58595B]";
  if (state === "checkedDisabled")
    return mode === "light"
      ? "text-[#858791]"
      : "text-[#CECFD3]";
  return "";
}

export default function LovableCheckboxDemo() {
  return (
    <div className="w-full flex justify-center py-8">
      <div className="relative w-[976px] h-[216px] border-dashed border-[#9747FF] border rounded-[5px] flex flex-col items-center justify-center p-6">
        {/* Two columns: Light / Dark */}
        <div className="flex gap-[48px]">
          {MODES.map((mode) => (
            <div key={mode} className="flex flex-col gap-4">
              {STATES.map(({ state, label }, idx) => {
                const box = getCheckboxStyles(state, mode);
                return (
                  <label key={state + mode} className="flex flex-row items-center gap-2 min-w-[175px] h-6">
                    <span className={`relative w-6 h-6 flex items-center justify-center`}>
                      {/* Checkbox box */}
                      <span className={`
                        absolute w-4 h-4 top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2
                        rounded-[4px] ${box.box}
                      `}/>
                      {/* Checkmark */}
                      <span className={box.check}/>
                      {/* Indeterminate bar */}
                      <span className={box.indeterminate}/>
                    </span>
                    <span className={`
                      font-['Roboto'] font-normal text-[16px] leading-6 select-none
                      ${getTextStyles(state, mode)}
                    `}>
                      {label}
                    </span>
                  </label>
                );
              })}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


Info
Checkboxes allow users to select one or more options from a set (multi-select). They support checked, unchecked, and indeterminate states.

Principles
Clarity: Make checked, unchecked, and indeterminate states visually distinct.


Accessibility: Always use clear, visible states for all modes (checked, hover, focus, disabled); labels must be next to checkboxes.


Consistency: Style and behavior remain consistent across light/dark modes and all contexts.


Feedback: Immediate visual feedback on hover, focus, and click.


Hierarchy: Clearly distinguish checkboxes (multi-select) from radio buttons (single-select).



Anatomy
Checkbox Container: Square box, large enough for easy tapping/clicking (e.g., 20x20 px or 24x24 px).


Checkmark/Indicator:


Checked: ✓ (checkmark)


Indeterminate: — (dash)


Label: Text aligned right of checkbox, always present for context.


Hover/Focus States: Visual ring, border, or subtle background change for accessibility.


Disabled State: Checkbox and label appear faded/grayed out; non-interactive.



States
Unchecked: Empty box.


Checked: Box filled with checkmark.


Indeterminate: Box filled with dash.


Disabled: Lower opacity, no interaction.


Hover/Focus: Subtle border or shadow highlight.



Usage Guidelines
Checked: Used when option is selected.
 When: Any item in a group can be chosen; e.g., select multiple interests.


Unchecked: Used when option is not selected.
 When: Allow users to leave an option unselected.


Indeterminate: Used when some, but not all, sub-options are selected.
 When: Parent group of sub-options (e.g., folder with some files checked).


Disabled: Used when not interactive.
 When: Certain conditions must be met before enabling selection.


Hover/Focus:


Hover: Slight color/border change on mouse over.


Focus: Clear focus ring or border for keyboard navigation.



Best Practices in Figma
Component Properties:


State (Checked, Unchecked, Indeterminate, Disabled)


Label (Text override)


Auto Layout:


Use horizontal auto layout for label and checkbox; consistent spacing (e.g., 8px gap).


Design Tokens:


Color, spacing, border radius, focus ring—all use system tokens.


Accessibility:


Minimum 44x44 px hit area


Sufficient contrast (4.5:1)


Label is never just the checkbox alone—always text or accessible label
Radio Buttons – Lovable Design System

Code:

import React, { useState } from "react";

const radioList = [
  { label: "Radio", state: "default" },
  { label: "Radio", state: "selected" },
  { label: "Radio", state: "disabled" },
  { label: "Radio", state: "selected-disabled" },
];

export default function LovableRadioGroup() {
  const [selected, setSelected] = useState(1);

  return (
    <div className="bg-white p-6 rounded-md border border-dashed border-[#9747FF] w-fit flex flex-col gap-6">
      {radioList.map((item, idx) => {
        const isSelected = item.state.includes("selected");
        const isDisabled = item.state.includes("disabled");
        let borderColor = isSelected ? "border-[#1B489B]" : "border-[#303030]";
        let dotBg =
          isSelected && !isDisabled
            ? "bg-[#1B489B]"
            : isSelected && isDisabled
            ? "bg-[#CECFD3]"
            : "";
        let labelColor = isDisabled
          ? "text-[#858791]"
          : isSelected
          ? "text-[#1B489B]"
          : "text-[#303030]";
        let radioBorder =
          isDisabled && isSelected
            ? "border-[#D4DAEA]"
            : isDisabled
            ? "border-[#CECFD3]"
            : borderColor;

        return (
          <label
            key={idx}
            className={`flex items-center gap-3 cursor-pointer select-none ${
              isDisabled ? "cursor-not-allowed" : ""
            }`}
          >
            <span
              className={`
                relative flex items-center justify-center 
                w-6 h-6 rounded-full border 
                ${radioBorder} 
                transition
                ${isDisabled ? "" : "hover:ring-2 hover:ring-[#E9ECF4]"}
              `}
            >
              {/* Outer circle */}
              <input
                type="radio"
                checked={selected === idx}
                disabled={isDisabled}
                onChange={() => setSelected(idx)}
                className="opacity-0 absolute w-full h-full cursor-pointer"
                tabIndex={isDisabled ? -1 : 0}
              />
              {/* Dot */}
              {(isSelected || isDisabled) && (
                <span
                  className={`block w-2.5 h-2.5 rounded-full ${dotBg}`}
                  style={{
                    background:
                      isSelected && !isDisabled
                        ? "#1B489B"
                        : isSelected && isDisabled
                        ? "#CECFD3"
                        : "transparent",
                  }}
                />
              )}
            </span>
            <span
              className={`font-['Roboto'] text-[16px] leading-6 ${labelColor}`}
            >
              {item.label}
            </span>
          </label>
        );
      })}
    </div>
  );
}


Info
Radio buttons allow users to select one option from a group of mutually exclusive choices. Selecting one automatically deselects the others.

Principles
Mutual Exclusivity: Only one selection per group.


Clarity: Selected state = filled circle. Unselected = empty circle.


Consistency: Uniform size, style, and behavior across all usages.


Accessibility: Easy to interact with and visually distinguishable. Always paired with labels.


Feedback: Immediate visual feedback for hover, focus, selected, and disabled states.



Anatomy
Radio Container: Outer circular shape.


Selected State: Filled center circle.


Unselected State: Empty circle with visible border.


Label: Placed to the right, always present, clearly describing the option.


Hover/Focus States: Subtle border color or shadow change. Focus ring for accessibility.


Disabled State: Both radio and label are grayed out; non-interactive.



States
Selected: Circle filled with a dot/center circle, clear border.


Unselected: Empty circle with border.


Disabled: Lower opacity, grayed out, no interaction.


Hover/Focus: Highlight border or show focus ring.



Usage Guidelines
Selected State: Indicates current choice.


When to use: Mutually exclusive choices (e.g., Yes/No, plan selection).


Visual style: Filled center.


Unselected State: All other options.


When to use: Options not currently selected.


Visual style: Empty circle.


Disabled State: Not available for selection.


When to use: Selection is not allowed due to context.


Visual style: Both radio and label faded out.


Hover/Focus:


Hover: Slight color/border change.


Focus: Focus ring for keyboard accessibility.



Best Practices in Figma
Component Properties:


State (Selected, Unselected, Disabled)


Label (Text override)


Auto Layout:


Horizontal layout, label always aligned with radio, consistent gap (e.g., 8px).


Design Tokens:


Color, spacing, border width—all use system tokens.


Accessibility:


Minimum 44x44 px touch target


Contrast ratio 4.5:1 or better


Always used with a text label



Switch / Toggle – Lovable Design System

Code

import React, { useState } from "react";

function LovableSwitch({ checked, onChange, dark = false }) {
  return (
    <button
      type="button"
      aria-pressed={checked}
      onClick={onChange}
      className={`
        w-16 h-8 rounded-[24px] flex items-center transition-colors 
        ${dark
          ? checked
            ? "bg-[#858791]"
            : "bg-[#CECFD3]"
          : checked
            ? "bg-[#1B489B]"
            : "bg-[#E7E7E9]"
        }
        px-0 relative
      `}
      style={{ minWidth: 64, minHeight: 32 }}
      tabIndex={0}
    >
      <span
        className={`
          absolute left-0 top-0 h-8 w-16
          pointer-events-none
        `}
      >
        <span
          className={`
            block absolute top-1 left-1
            h-7 w-7 bg-white rounded-full shadow
            transition-transform
            ${checked ? "translate-x-7" : ""}
          `}
          style={{
            transition: "transform 0.2s",
          }}
        />
      </span>
      {/* Hidden input for accessibility */}
      <input
        type="checkbox"
        checked={checked}
        onChange={onChange}
        className="sr-only"
        tabIndex={-1}
      />
    </button>
  );
}

export default function SwitchDemoLovable() {
  const [light, setLight] = useState(false);
  const [light2, setLight2] = useState(true);
  const [dark, setDark] = useState(false);
  const [dark2, setDark2] = useState(true);

  return (
    <div className="flex flex-wrap gap-10 bg-transparent p-6 border-2 border-dashed border-[#9747FF] rounded-lg w-max">
      <div className="flex flex-col gap-10">
        {/* Light mode */}
        <LovableSwitch checked={light} onChange={() => setLight((v) => !v)} />
        <LovableSwitch checked={light2} onChange={() => setLight2((v) => !v)} />
      </div>
      <div className="flex flex-col gap-10">
        {/* Dark mode background */}
        <div className="flex flex-col gap-10 bg-black p-2 rounded-lg">
          <LovableSwitch checked={dark} onChange={() => setDark((v) => !v)} dark />
          <LovableSwitch checked={dark2} onChange={() => setDark2((v) => !v)} dark />
        </div>
      </div>
    </div>
  );
}


Info
Toggles represent a binary ON/OFF state. Use for actions where users can instantly enable or disable a setting. Clear and immediate state change, no confirmation needed.

Principles
Clarity: Show current state clearly (on/off) using color and position.


Immediate Feedback: Visual feedback (color/position) updates instantly on change.


Consistency: Style and behavior match across all platforms and contexts.


Accessibility: State is clear through both color and position/label for all users, including screen readers.


Intuitive Interaction: Thumb slides right for "on", left for "off", mimicking real switches.



Anatomy
Toggle Container: Track shape (rectangle/oval) showing the path of the thumb. Changes color by state.


Thumb: The circular slider users move (right = on, left = off).


On State: Track filled with accent color (e.g., blue/green), thumb on the right.


Off State: Track gray/muted, thumb on the left.


Hover/Focus: Subtle shadow or border on hover. Focus ring for accessibility.



Usage
On State


Purpose: Indicates an option/setting is enabled or active.


Visual: Track colored, thumb right.


Off State


Purpose: Indicates an option/setting is disabled or inactive.


Visual: Track muted/gray, thumb left.


Hover: Shadow/border signals interactivity.


Focus: Focus ring/outline around thumb for keyboard access.



Best Practices for Figma
Component Properties:


State (On, Off, Disabled)


Size (if needed, e.g., small/large)


Auto Layout:


Container + thumb, horizontal alignment.


Tokens:


Use system color tokens for track and thumb.


Accessibility:


44x44 px minimum tap target.


Sufficient color contrast.


Provide aria-label or visible text for assistive tech.
Stepper – Lovable Design System

Code

import React from "react";

// Demo data for 5-step steppers
const steppers = [
  { current: 0, steps: 5, dark: false }, // All inactive
  { current: 1, steps: 5, dark: false }, // Step 1 complete
  { current: 2, steps: 5, dark: false }, // Step 2 complete
  { current: 3, steps: 5, dark: false }, // Step 3 complete
  { current: 4, steps: 5, dark: false }, // Step 4 complete
  { current: 5, steps: 5, dark: false }, // All completed
  { current: 0, steps: 4, dark: false }, // 4 steps
  { current: 0, steps: 5, dark: true },
  { current: 1, steps: 5, dark: true },
  { current: 2, steps: 5, dark: true },
  { current: 3, steps: 5, dark: true },
  { current: 4, steps: 5, dark: true },
  { current: 5, steps: 5, dark: true },
  { current: 0, steps: 4, dark: true },
];

function getStepState(idx, current) {
  if (idx < current) return "done";
  if (idx === current) return "active";
  return "inactive";
}

function Stepper({ steps = 5, current = 0, dark = false }) {
  return (
    <div className={`flex items-center w-full mb-4`}>
      {[...Array(steps)].map((_, idx) => {
        const state = getStepState(idx, current);
        const isLast = idx === steps - 1;
        return (
          <React.Fragment key={idx}>
            <div className="flex flex-col items-center">
              <div
                className={`
                  flex items-center justify-center
                  w-6 h-6 rounded-full
                  border
                  ${state === "done" ? (dark ? "bg-[#0C0F24] border-[#0C0F24]" : "bg-[#0C0F24] border-[#0C0F24]")
                    : state === "active" ? (dark ? "bg-[#858791] border-[#CECFD3]" : "bg-white border-[#0C0F24]") 
                    : dark ? "bg-[#858791] border-[#CECFD3]" : "bg-white border-[#CECFD3]"}
                  transition
                `}
              >
                {state === "done" ? (
                  <svg width={16} height={16} viewBox="0 0 16 16" fill="none">
                    <path d="M4 8.5L7 11L12 6" stroke="#fff" strokeWidth={2} strokeLinecap="round" strokeLinejoin="round" />
                  </svg>
                ) : (
                  ""
                )}
              </div>
              <span
                className={`text-xs mt-1 ${dark ? "text-white" : "text-black"} font-normal`}
              >
                Step {idx + 1}
              </span>
            </div>
            {!isLast && (
              <div
                className={`
                  flex-1 h-0.5 mx-1
                  ${idx < current
                    ? dark
                      ? "bg-white"
                      : "bg-[#0C0F24]"
                    : dark
                      ? "bg-[#CECFD3]"
                      : "bg-[#CECFD3]"}
                `}
                style={{ minWidth: 24 }}
              />
            )}
          </React.Fragment>
        );
      })}
    </div>
  );
}

export default function LovableHorizontalStepper() {
  return (
    <div className="border border-dashed border-[#9747FF] rounded-[5px] p-10 bg-black">
      <div className="grid grid-cols-2 gap-8">
        {/* Left Column: Light Mode */}
        <div>
          {[0, 1, 2, 3, 4, 5].map((curr) => (
            <Stepper key={curr} steps={5} current={curr} dark={false} />
          ))}
          <Stepper steps={4} current={0} dark={false} />
        </div>
        {/* Right Column: Dark Mode */}
        <div>
          {[0, 1, 2, 3, 4, 5].map((curr) => (
            <Stepper key={curr} steps={5} current={curr} dark={true} />
          ))}
          <Stepper steps={4} current={0} dark={true} />
        </div>
      </div>
    </div>
  );
}


Info
Steppers visualize a user’s progress through a series of steps in complex workflows. Each step is clearly labeled and visually distinct. Useful for onboarding, checkout, multi-step forms, etc.
Supported: Horizontal & Vertical layouts


Platforms: Web, Mobile



Principles
Clarity: Always highlight the current step. Completed/upcoming steps must be clearly distinguishable.


Progress Visibility: Progress is visually apparent using filled indicators or icons.


Accessibility: Steps should be navigable for all users—use clear visual indicators, good color contrast, and text for each step.



Anatomy
Horizontal Stepper
Step Indicator: Numbered circle or icon for each step. Completed steps are filled, upcoming steps are outlined.


Connector Line: Horizontal line linking each step. The completed portion is visually highlighted (accent color).


Labels: Text below/next to each step for clarity (“Step 1”, “Step 2”, etc.). Optional subtext for instructions or details.


Vertical Stepper
Step Indicator: Numbered circle or icon, stacked vertically. Same filled/outlined approach.


Connector Line: Vertical line linking steps, with completed section visually highlighted.


Labels: Text right of the indicator, with optional subtext for context/instructions.



Usage & States
Current Step: Bold, filled indicator, label stands out.


Completed Step: Filled indicator, highlighted connector, label regular.


Upcoming Step: Outlined indicator, connector muted/gray, label muted.


Hover/Focus: Slight shadow or color change for interactivity/accessibility.


Optional: Subtext for extra detail.



Best Practices (Figma)
Variants:


Orientation (Horizontal, Vertical)


State (Current, Completed, Upcoming, Disabled)


With Subtext (true/false)


Auto Layout:


Use stacks for easy vertical/horizontal switching.


Design Tokens:


Use system colors for filled, outlined, and disabled states.


Accessibility:


44px min touch targets


Clear color contrast


Provide step labels for screen readers.



Naming (Figma)
Stepper / [Orientation] / [Step State] / [Subtext]



Progress Bar – Lovable Design System

Code Dark

const progressBars = [
  { percent: 0 },
  { percent: 20 },
  { percent: 50 },
  { percent: 75 },
  { percent: 90 }
];

export default function LovableProgressBarDark() {
  return (
    <div className="flex flex-col gap-11 border border-dashed border-[#9747FF] rounded-[5px] p-[50px] w-[537px] h-[678px] bg-black">
      {/* Regular Progress Bars */}
      {progressBars.map(({ percent }) => (
        <div key={percent} className="flex items-center gap-3 w-[437px] h-6">
          <div className="relative w-[404px] h-2 bg-[#E9ECF4] rounded-full">
            <div
              className="absolute h-2 bg-[#3D3F50] rounded-full"
              style={{
                width: `${Math.max(10, (404 * percent) / 100)}px`,
                minWidth: percent === 0 ? "10px" : undefined
              }}
            />
          </div>
          <span className="text-[#131529] text-[20px] font-normal leading-6 ml-2 select-none" style={{ width: 46 }}>
            {percent}%
          </span>
        </div>
      ))}

      {/* Success */}
      <div className="flex flex-col gap-1 w-[437px]">
        <div className="flex items-center gap-3 w-[437px]">
          <div className="w-[404px] h-2 bg-[#258458] rounded-full" />
          {/* Check Circle SVG */}
          <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
            <circle cx="12" cy="12" r="12" fill="none"/>
            <path d="M7 13l3 3 7-7" stroke="#258458" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
          </svg>
        </div>
        <span className="text-[#258458] text-[24px] font-normal leading-6 ml-1">Successful Text</span>
      </div>

      {/* Failed (dark gold) */}
      <div className="flex flex-col gap-1 w-[437px]">
        <div className="flex items-center gap-3 w-[437px]">
          <div className="w-[404px] h-2 bg-[#895D0B] rounded-full" />
          {/* Exclamation SVG */}
          <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
            <circle cx="12" cy="12" r="12" fill="none"/>
            <circle cx="12" cy="20" r="2" fill="#895D0B"/>
            <rect x="11" y="6" width="2" height="8" rx="1" fill="#895D0B"/>
          </svg>
        </div>
        <span className="text-[#895D0B] text-[24px] font-normal leading-6 ml-1">Failed Text</span>
      </div>

      {/* Failed (light gold) */}
      <div className="flex flex-col gap-1 w-[437px]">
        <div className="flex items-center gap-3 w-[437px]">
          <div className="w-[404px] h-2 bg-[#FFE1A4] rounded-full" />
          {/* Exclamation SVG */}
          <svg width="28" height="28" viewBox="0 0 24 24" fill="none">
            <circle cx="12" cy="12" r="12" fill="none"/>
            <circle cx="12" cy="20" r="2" fill="#FFE1A4"/>
            <rect x="11" y="6" width="2" height="8" rx="1" fill="#FFE1A4"/>
          </svg>
        </div>
        <span className="text-[#895D0B] text-[24px] font-normal leading-6 ml-1">Failed Text</span>
      </div>
    </div>
  );
}
Code Light

import { CheckCircle, AlertCircle } from "lucide-react";

const progressData = [
  { value: 0, label: "0%" },
  { value: 20, label: "20%" },
  { value: 50, label: "50%" },
  { value: 75, label: "75%" },
  { value: 90, label: "90%" },
];

export default function LovableProgressBar() {
  return (
    <div className="flex flex-col gap-11 bg-[#E9ECF4] border border-dashed border-[#9747FF] rounded-[5px] p-[50px] w-[546px] mx-auto">
      {/* Progress Bars */}
      {progressData.map((item) => (
        <div key={item.value} className="flex items-center gap-3 w-[446px] h-6">
          {/* Progress Container */}
          <div className="relative flex items-center w-[404px] h-2 bg-white rounded-full">
            <div
              className="absolute top-0 left-0 h-2 bg-[#3D3F50] rounded-full"
              style={{
                width: `${item.value}%`,
                minWidth: item.value === 0 ? "10px" : undefined,
                transition: "width 0.5s cubic-bezier(.4,2.3,.3,1)"
              }}
            />
          </div>
          {/* Label */}
          <span className="text-[#0C0F24] text-[16px] font-normal leading-6 select-none" style={{ width: 30 }}>
            {item.label}
          </span>
        </div>
      ))}

      {/* Successful Progress */}
      <div className="flex items-center gap-3 w-[436px] h-[50px]">
        <div className="flex items-center w-[400px] h-2 bg-[#1E774A] rounded-full" />
        <CheckCircle className="text-[#1E774A] w-6 h-6" strokeWidth={2} fill="none" />
      </div>
      <span className="text-[#1E774A] text-[20px] font-normal leading-6 ml-1 -mt-6 mb-4">
        Successful Text
      </span>

      {/* Failed Progress */}
      <div className="flex items-center gap-3 w-[436px] h-[50px]">
        <div className="flex items-center w-[400px] h-2 bg-[#895D0B] rounded-full" />
        <AlertCircle className="text-[#895D0B] w-6 h-6" strokeWidth={2} fill="none" />
      </div>
      <span className="text-[#895D0B] text-[20px] font-normal leading-6 ml-1 -mt-6">
        Failed Text
      </span>
    </div>
  );
}


Info
Progress bars visually communicate a user’s progress through a sequence of steps or toward completing a task. They highlight what’s complete, what’s in progress, and what’s next—helping users track where they are and what’s left to do.

Principles
Progress Indication: Clearly show completion, current, and upcoming steps.


Clarity: Use clear step labels so users know what each stage means.


Consistency: Visual style should be consistent across the app. Use the same indicators, spacing, and tokens.


Feedback: Give immediate visual feedback as users move forward.


Accessibility: All statuses (active, completed, inactive) must be distinguishable by more than color; include clear icons/labels for screen readers.



Anatomy
Step Indicator: Circle, icon, or checkmark showing complete, active, or inactive.


Connector Line: Connects steps visually, showing path and progress.


Step Label: Text below/next to indicator, with optional subtext.


Subtext (Optional): Additional instructions/details for each step.


Completed State: Distinct visual indicator (filled, checked, colored).


Active State: Visually highlighted, using a bold/fill color.


Inactive State: Outlined/gray or muted, to show what’s upcoming.



Variants (Figma)
Types: Linear (default), Circular (optional for Lovable, if needed)


States:


Completed (filled/colored or checkmark)


Active (highlighted, possibly with animated bar or pulsing color)


Inactive (gray, outline, low emphasis)


Color:


Use system accent for progress, muted for inactive, success for done, warning for errors.



Best Practices
Auto Layout: Use for stacking progress bar segments or horizontal steps.


Spacing: 8–16px gap between bars and labels.


Labels: Always include text labels, never rely on color alone.


Sizing: Height 6–8px for linear bars; minimum 44px touch targets for interactive elements.


Accessibility:


Use aria-valuenow, aria-valuemax, aria-label for screen readers.


Ensure color contrast ≥ 4.5:1.



Naming (Figma)
Progress Bar / [Type] / [State] / [Label Variant]

Tooltips – Lovable Design System
Overview
Tooltips provide concise, contextual messages on hover or focus to clarify interface elements without clutter. They’re essential for onboarding, explaining actions, and reducing user friction.

Principles
Clarity: Give short, actionable info—no jargon, no paragraphs.


Non-intrusiveness: Show only on hover/focus. Disappear when not needed.


Consistency: Same shape, style, spacing, and font everywhere.



Anatomy
Container: Rectangle with 4–8px radius (Lovable = rounded, friendly), soft shadow for elevation.


Pointer/Tail: Small triangle or “notch” pointing to trigger element.


Title (optional): Short, bolded heading for rich tooltips.


Description: Concise message; never more than two lines if possible.


Link (optional): “Learn more” or similar for advanced or interactive tooltips.


States:
Default


With action/link


With/without title


Positioning:
Above, below, left, or right—auto-position for viewport boundaries.



Variants (Figma)
Tooltip / Default / Top


Tooltip / Default / Bottom


Tooltip / With Link


Tooltip / With Title


Mobile and desktop sizing



Sizing
Min width: 120px


Max width: 280px (truncate text or wrap)


Padding: 12–16px


Font: Use Lovable’s smallest readable text size (usually 12–14px), with 1.2–1.4 line height



Accessibility
Triggered by keyboard (focusable, not just hover)


Dismissed by ESC or click outside for persistent tooltips


Use aria-describedby to connect tooltip to trigger


High contrast background (e.g., dark bg, white text or vice versa)



Usage Best Practices
Only show on hover/focus, not on click—except for tooltips with actions.


Place close to the triggering element (8px offset).


Don’t stack multiple tooltips at once.


Avoid over-explaining common actions.



Figma Tips
Create tooltip as a component with slot for content.


Use variants for direction, with/without link, with/without title.


Add auto layout for padding and easy resizing.
Dropdowns – Lovable Design System

Code
import React, { useState, useRef, useEffect } from "react";

const items = ["Item 1", "Item 2", "Item 3", "Item 4", "Item 5"];

export default function LovableDropdown() {
  const [open, setOpen] = useState(false);
  const [selected, setSelected] = useState("Default Item");
  const dropdownRef = useRef();

  // Close dropdown on outside click
  useEffect(() => {
    function handle(e) {
      if (!dropdownRef.current.contains(e.target)) setOpen(false);
    }
    if (open) document.addEventListener("mousedown", handle);
    return () => document.removeEventListener("mousedown", handle);
  }, [open]);

  return (
    <div className="min-h-[340px] bg-black border border-dashed border-[#9747FF] rounded-[5px] flex items-start gap-16 p-10">
      {/* Closed Dropdown */}
      <div className="relative" ref={dropdownRef}>
        <button
          className={`
            flex items-center justify-between w-[240px] h-[64px] px-6 py-0
            bg-[#FAFAFA] rounded-[12px]
            font-['Roboto'] font-semibold text-[28px] leading-9 text-[#303030]
            focus-visible:outline focus-visible:ring-2 ring-[#1B489B]
            transition
            border-none
            shadow
          `}
          onClick={() => setOpen((o) => !o)}
          aria-haspopup="listbox"
          aria-expanded={open}
        >
          <span>{selected}</span>
          <svg width={32} height={32} viewBox="0 0 24 24" fill="none" className={`transition-transform duration-200 ${open ? "rotate-180" : ""}`}>
            <path d="M7 10l5 5 5-5" stroke="#303030" strokeWidth={2.2} strokeLinecap="round" strokeLinejoin="round" />
          </svg>
        </button>
        {/* Open menu */}
        {open && (
          <div className="absolute left-0 top-[72px] w-[350px] bg-[#FAFAFA] rounded-b-[16px] rounded-t-[0px] shadow-lg border border-t-0 border-[#E5E5E5] z-30">
            <div className="flex items-center justify-between w-full px-6 pt-5 pb-4 border-b border-[#E5E5E5] font-['Roboto'] font-semibold text-[28px] text-[#303030] rounded-t-[16px]">
              {selected}
              <svg width={32} height={32} viewBox="0 0 24 24" fill="none" className={`rotate-180`}>
                <path d="M7 10l5 5 5-5" stroke="#303030" strokeWidth={2.2} strokeLinecap="round" strokeLinejoin="round" />
              </svg>
            </div>
            <div className="flex flex-col px-6 py-6 gap-7">
              {items.map((item) => (
                <button
                  key={item}
                  className={`
                    text-left font-['Roboto'] text-[28px] leading-9 text-[#303030]
                    focus-visible:outline focus-visible:ring-2 ring-[#1B489B] rounded px-2 py-1
                    transition
                    ${selected === item ? "font-bold" : ""}
                  `}
                  role="option"
                  onClick={() => { setSelected(item); setOpen(false); }}
                  tabIndex={0}
                >
                  {item}
                </button>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* Spacer for visual parity (right menu mockup in your image) */}
      <div className="w-[420px]" />
    </div>
  );
}


Purpose
Dropdowns let users pick a single option from a list, saving space and streamlining forms, filters, or navigation.

Core Principles
Clarity: Label everything clearly—users must always know what they’re selecting.


Ease of Use: Should be easy to open, browse, select, and close. Selected item is obvious.


Accessibility: Fully keyboard-navigable, focus states visible, ARIA labels for screen readers.



Anatomy
Container:


Shows current selection.


Includes dropdown arrow indicator (chevron).


Label (optional):


Text label above or beside for context.


Expanded Menu:


List of options, scrollable if many.


Each option: clear label, enough padding, and selected/hover states.


Options:


Current selection highlighted (e.g., with color or icon).


No options hidden—always readable.


States:


Closed (default), Expanded, Hover, Focus, Selected, Disabled.



Behavior
Trigger: Click/tap (mouse/touch), or Enter/Space (keyboard).


Navigation: Arrow keys to move, Enter to select, Esc to close.


Selection:


Only one item at a time.


Selecting closes menu and updates trigger text.


Click Outside: Closes the menu.



Design Guidelines
Closed State:


Compact, shows selected item, always shows chevron for discoverability.


Expanded State:


Align menu to trigger; avoid cutting off by viewport edges (flip if needed).


Scrollable if list is long (never let it overflow the viewport).


Touch targets:


At least 44x44px (mobile).


Labels:


Concise and clear (truncate if too long, but show full text on hover or tooltip).



Responsive Behaviour
Mobile:


Menu may expand to full-screen or modal for easier touch selection.


Always large enough for finger taps—no tiny options!


Web:


Menu aligns to available space, never overflows.


Scroll for long lists; set a max-height (e.g., 320px) with internal scroll.



Figma Component Tips
Variants:


Closed, Open, Disabled, Error (for form validation)


Auto layout:


For options list; allows easy resizing and consistent spacing.


Slot for icon/left content:


Allows checkmark or icon in selected state.


Use “Instance Swap” for icons or custom option content.


Interactions:


Prototype “Open” on click, and selection/highlight on hover.



Accessibility Must-Haves
Keyboard navigation


Clear focus outline


aria-expanded, aria-controls, and proper labeling for the trigger



Alerts – Lovable Design System

Code

import React from "react";

const ICONS = {
  info: (
    <svg width="24" height="24" fill="none" aria-hidden="true">
      <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="2" />
      <rect x="11" y="7" width="2" height="2" fill="currentColor" />
      <rect x="11" y="11" width="2" height="6" fill="currentColor" />
    </svg>
  ),
  success: (
    <svg width="16" height="16" fill="none" aria-hidden="true">
      <circle cx="8" cy="8" r="8" fill="currentColor" opacity="0.16" />
      <path
        d="M4 8.5l2.5 2.5 5-5"
        stroke="currentColor"
        strokeWidth="2"
        strokeLinecap="round"
        strokeLinejoin="round"
      />
    </svg>
  ),
  warning: (
    <svg width="24" height="24" fill="none" aria-hidden="true">
      <circle cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="2" />
      <path d="M12 8v4" stroke="currentColor" strokeWidth="2" strokeLinecap="round" />
      <circle cx="12" cy="16" r="1" fill="currentColor" />
    </svg>
  ),
};

const variantStyles = {
  info: {
    light: "bg-[#D4DAEA] text-[#0C0F24] border-[#D4DAEA]",
    dark: "bg-[#0C0F24] text-[#E7E7E9] border-[#0C0F24]",
    icon: "text-[#0C0F24] dark:text-[#E7E7E9]",
  },
  success: {
    light: "bg-[#CCF2DB] text-[#1E774A] border-[#CCF2DB]",
    dark: "bg-[#1E774A] text-[#CCF2DB] border-[#1E774A]",
    icon: "text-[#1E774A] dark:text-[#CCF2DB]",
  },
  warning: {
    light: "bg-[#FFE1A4] text-[#895D0B] border-[#FFE1A4]",
    dark: "bg-[#895D0B] text-[#FFE1A4] border-[#895D0B]",
    icon: "text-[#895D0B] dark:text-[#FFE1A4]",
  },
};

export function AlertBanner({
  variant = "info", // 'info' | 'success' | 'warning'
  theme = "light", // 'light' | 'dark'
  title,
  message,
}) {
  const styles = variantStyles[variant][theme];
  const iconStyle = variantStyles[variant].icon;

  return (
    <div
      className={`flex items-center gap-2 px-4 py-4 mb-4 rounded-md border ${styles}`}
      role="alert"
    >
      <span className={`mr-2 ${iconStyle}`}>{ICONS[variant]}</span>
      <span>
        <span className="font-bold font-roboto mr-1">{title}</span>
        <span className="font-roboto">{message}</span>
      </span>
    </div>
  );
}

// Example usage
export default function AlertsDemo() {
  return (
    <div className="w-[740px] bg-black/90 border border-dashed border-[#9747FF] rounded-lg p-4 flex flex-col gap-3">
      <AlertBanner
        variant="info"
        theme="light"
        title="Tip!"
        message="You can now have cover images on blog pages. Drafts will now auto-save while writing."
      />
      <AlertBanner
        variant="info"
        theme="dark"
        title="Tip!"
        message="You can now have cover images on blog pages. Drafts will now auto-save while writing."
      />
      <AlertBanner
        variant="success"
        theme="light"
        title="Success!"
        message="You may now proceed with your workflow."
      />
      <AlertBanner
        variant="success"
        theme="dark"
        title="Success!"
        message="You may now proceed with your workflow."
      />
      <AlertBanner
        variant="warning"
        theme="light"
        title="Warning!"
        message="You must register before you can do that."
      />
      <AlertBanner
        variant="warning"
        theme="dark"
        title="Warning!"
        message="You must register before you can do that."
      />
    </div>
  );
}


Purpose
Alerts communicate important info such as success, tips, warnings, or errors. They grab user attention and provide clear, actionable feedback without overwhelming or blocking workflow.

Core Principles
Clarity: Simple, direct messaging.


Visual Hierarchy:


Green for success


Blue for info/tip


Yellow for warning


Red for error


Use matching icons (checkmark, info, warning, error).


Non-intrusive: Don’t block workflow unless truly critical. Alerts should be dismissible if not blocking.


Accessibility: Sufficient color contrast, clear icons, and text for screen readers.



Anatomy
Icon:


Left-aligned, matches alert type (e.g., checkmark for success).


Text Content:


Title: Bold, clear statement of type (e.g., “Success!”, “Warning!”).


Description: Short explanation or details.


Background Color: Matches type.


Placement: Above or near related content or actions. Never hidden at bottom of screen.



Types & Use
Success:


Green, checkmark, brief confirmation, after a positive action.


Tip/Info:


Blue, info icon, gentle guidance, for helpful hints.


Warning:


Yellow, exclamation, call out important requirements or risks.


Error:


Red (not shown), cross icon, explain problem and how to resolve.



Interaction & Responsive
Dismissible:


Alerts can be dismissed on mobile by swipe/tap, or with an explicit close action (unless blocking).


Scaling:


Layout and icons stay readable and balanced on all devices.



Content Guidelines
Title first: “Success!”, “Warning!”, “Error!”


Specific message: State what happened and what to do next.


Optional Action: Link, button, or next step.


Tone:


Success/tips: Upbeat, friendly.


Warning: Calm but clear, not alarming.


Error: Supportive, suggest solutions.



Style Tips
Active voice: “You can now upload images,” not “Images can now be uploaded.”


No exclamation overload: Use them sparingly and only for real excitement.


No apologies for errors: Focus on solutions and next steps.


Avoid negativity: Frame actions users can take.



Figma/Component Tips
Variants: Success, Info, Warning, Error, with/without close icon.


Auto Layout: Padding, icon slot, text stack.


Adaptive: Responsive resizing for mobile/web.


Props for devs: type, title, description, action, onDismiss.


Text Fields – Lovable Design System

Code
import React from "react";
import clsx from "clsx";

const COLORS = {
  light: {
    label: "text-[#303030]",
    base: "bg-white border-[#CECFD3] text-[#858791] placeholder-[#858791]",
    focus: "bg-white border-[#3D3F50]",
    error: "bg-white border-[#895D0B]",
    success: "bg-white border-[#1E774A]",
    disabled: "bg-[#F4F4F7] border-[#CECFD3] text-[#C0C2CC] placeholder-[#C0C2CC]",
    errorText: "text-[#895D0B]",
    successText: "text-[#1E774A]",
  },
  dark: {
    label: "text-white",
    base: "bg-[#0C0F24] border-[#858791] text-[#858791] placeholder-[#858791]",
    focus: "bg-[#0C0F24] border-[#E7E7E9]",
    error: "bg-[#0C0F24] border-[#FFE1A4]",
    success: "bg-[#0C0F24] border-[#CCF2DB]",
    disabled: "bg-[#202238] border-[#858791] text-[#35394a] placeholder-[#35394a]",
    errorText: "text-[#FFE1A4]",
    successText: "text-[#CCF2DB]",
  },
};

const SIZES = {
  sm: "h-8 px-2 text-[14px]",
  base: "h-12 px-3 text-[16px]",
  lg: "h-14 px-3 text-[16px]",
  xl: "h-14 px-4 text-[16px]",
};

export function TextField({
  label = "Label",
  value,
  onChange,
  placeholder = "Text here",
  size = "base", // 'sm' | 'base' | 'lg' | 'xl'
  mode = "light", // 'light' | 'dark'
  state = "default", // 'default' | 'focus' | 'error' | 'success' | 'disabled'
  errorMessage = "",
  successMessage = "",
  ...props
}) {
  const isError = state === "error";
  const isSuccess = state === "success";
  const isDisabled = state === "disabled";
  const colors = COLORS[mode];

  return (
    <div className="flex flex-col gap-1 w-full max-w-[320px]">
      {/* Label */}
      <label
        className={clsx(
          "font-roboto font-normal",
          size === "sm" ? "text-[14px] leading-5" : "text-[16px] leading-6",
          isError
            ? colors.errorText
            : isSuccess
            ? colors.successText
            : colors.label
        )}
      >
        {label}
      </label>
      {/* Input */}
      <input
        type="text"
        value={value}
        onChange={onChange}
        placeholder={placeholder}
        disabled={isDisabled}
        className={clsx(
          "rounded-lg outline-none font-roboto w-full transition-all",
          SIZES[size],
          colors.base,
          "border",
          {
            [colors.focus]: state === "focus",
            [colors.error]: isError,
            [colors.success]: isSuccess,
            [colors.disabled]: isDisabled,
          }
        )}
        {...props}
      />
      {/* Feedback Message */}
      {isError && errorMessage && (
        <span className={clsx("font-roboto text-[12px] leading-[18px]", colors.errorText)}>
          {errorMessage}
        </span>
      )}
      {isSuccess && successMessage && (
        <span className={clsx("font-roboto text-[12px] leading-[18px]", colors.successText)}>
          {successMessage}
        </span>
      )}
    </div>
  );
}
Usage Example


export default function TextFieldDemo() {
  const [val, setVal] = React.useState("");

  return (
    <div className="w-full min-h-screen bg-black border border-dashed border-[#9747FF] rounded-lg p-6 grid grid-cols-3 gap-x-8 gap-y-4">
      {/* Light / Default / Base */}
      <TextField label="Label" placeholder="Text here" mode="light" size="base" state="default" />
      <TextField label="Label" placeholder="Text here" mode="light" size="base" state="focus" />
      <TextField label="Label" placeholder="Text here" mode="light" size="base" state="error" errorMessage="Error Message" />

      {/* Dark / Default / Base */}
      <TextField label="Label" placeholder="Text here" mode="dark" size="base" state="default" />
      <TextField label="Label" placeholder="Text here" mode="dark" size="base" state="focus" />
      <TextField label="Label" placeholder="Text here" mode="dark" size="base" state="error" errorMessage="Error Message" />

      {/* Success / Error / XL / LG / SM */}
      <TextField label="Label" placeholder="Text here" mode="light" size="xl" state="success" successMessage="Success" />
      <TextField label="Label" placeholder="Text here" mode="dark" size="xl" state="success" successMessage="Success" />
      <TextField label="Label" placeholder="Text here" mode="light" size="lg" state="error" errorMessage="Error Message" />
      <TextField label="Label" placeholder="Text here" mode="dark" size="lg" state="error" errorMessage="Error Message" />
      <TextField label="Label" placeholder="Text here" mode="light" size="sm" state="success" successMessage="Success" />
      <TextField label="Label" placeholder="Text here" mode="dark" size="sm" state="success" successMessage="Success" />
    </div>
  );
}



Purpose
Text fields let users input and edit text in forms, search bars, and more. They support general entry and validation/error handling.

Types
Default Text Fields: Standard entry, no immediate validation.


Error Text Fields: Highlight issues and display error messages for invalid or missing input.



Core Principles
Clarity: Labels and placeholders must clearly state what info is required.


Accessibility: Inputs must be readable and easy to navigate, with clear indicators for error and focus states.


Consistency: Uniform style and behavior across all text fields and screens.


Feedback: Provide instant feedback (focus, error/success messaging).



Anatomy
Label: Above the field, describes the input.


Input Field: Where the user types.


Placeholder: Light guidance, replaced when typing begins.


Error/Success Message: Below the field, details validation issues or successes.


Border:


Default: Gray or neutral.


Error: Yellow or highlighted to draw attention.



States
Default: For regular entry.


Focus: Visually clear when active.


Error: Highlight border, error text.


Success (if used): Green or confirmation message.


Disabled (if used): Muted appearance, not editable.


Light/Dark Mode: Support both themes for accessibility and consistency.



Usage Guidelines
Default Text Fields: Use for any general data entry (e.g., forms, search bars).


Error Text Fields: Use when validation fails; make sure error messages are specific and actionable.


Dark/Light Mode: Always provide text fields compatible with both modes.



Content & Microcopy
Labels: Should be short and descriptive (“Email Address”, “Card Number”).


Placeholders: Hint at the format or example (“Enter your email”).


Error Messages: Clearly state what’s wrong and how to fix (“Please enter a valid email address”).


Success Messages (if used): Confirm correct input (“Card added!”).



Best Practices
Use auto layout and variants in Figma for different states (default, focus, error, disabled).


Keep spacing and padding consistent for both desktop and mobile.


Support keyboard navigation and visible focus states.


Ensure high color contrast for accessibility.


Avoid using only color to indicate errors—pair with text or icons if needed.
Filters – Lovable Design System

Filter- Dropdown

import React, { useState } from "react";
import { IoClose, IoCalendarOutline } from "react-icons/io5";

function Checkbox({ label, checked, onChange }) {
  return (
    <label className="flex items-center gap-2 cursor-pointer text-[#0C0F24]">
      <input
        type="checkbox"
        className="accent-[#1B489B] w-5 h-5 rounded border-2 border-[#E7E7E9] focus:ring-2 focus:ring-[#1B489B] mr-1"
        checked={checked}
        onChange={onChange}
      />
      <span className="text-[16px] font-roboto">{label}</span>
    </label>
  );
}

function Collapsible({ label, children, checked, onCheck }) {
  const [open, setOpen] = useState(true);
  return (
    <div className="mb-1">
      <div className="flex items-center gap-2">
        <Checkbox label={label} checked={checked} onChange={onCheck} />
        <button
          className="ml-2 text-[#3D3F50]"
          onClick={() => setOpen(!open)}
          aria-label={open ? "Collapse" : "Expand"}
        >
          <svg width="20" height="21" className={open ? "rotate-180" : ""}>
            <path
              d="M5 9L10 14L15 9"
              stroke="#3D3F50"
              strokeWidth="2"
              fill="none"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </svg>
        </button>
      </div>
      {open && <div className="pl-7 mt-2 flex flex-col gap-2">{children}</div>}
    </div>
  );
}

export default function FiltersPanel() {
  const [startDate, setStartDate] = useState("2024/05/14");
  const [endDate, setEndDate] = useState("");
  const [checked, setChecked] = useState({
    info: false,
    infoItems: {},
    action: false,
    actionItems: {},
    recog: false,
    recogItems: {},
  });

  // Example child item check handling
  const handleChildCheck = (group, item) => e =>
    setChecked(prev => ({
      ...prev,
      [group]: prev[group] || false,
      [`${group}Items`]: {
        ...prev[`${group}Items`],
        [item]: e.target.checked,
      },
    }));

  const handleParentCheck = group => e =>
    setChecked(prev => ({
      ...prev,
      [group]: e.target.checked,
      [`${group}Items`]: Object.fromEntries(
        Object.entries(prev[`${group}Items`] || {}).map(([k, v]) => [k, e.target.checked])
      ),
    }));

  const clearAll = () => {
    setStartDate("");
    setEndDate("");
    setChecked({
      info: false,
      infoItems: {},
      action: false,
      actionItems: {},
      recog: false,
      recogItems: {},
    });
  };

  return (
    <div className="w-[375px] bg-white border border-[rgba(16,46,102,0.2)] shadow-xl rounded-lg p-5 font-roboto relative">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <span className="text-[18px] font-semibold text-[#3D3F50]">Filters</span>
        <button className="text-[#3D3F50] text-2xl">
          <IoClose />
        </button>
      </div>
      <hr className="border-[#E7E7E9] mb-4" />
      {/* By Date */}
      <div className="mb-6">
        <div className="flex justify-between items-center mb-2">
          <span className="text-[16px] font-semibold text-[#3D3F50]">By Date</span>
          <button className="text-[#1B489B] text-[14px] underline" onClick={clearAll}>
            Clear
          </button>
        </div>
        <div className="flex gap-4 mb-2">
          <div>
            <label className="block text-[14px] text-[#3D3F50] mb-1">Start Date</label>
            <div className="relative">
              <input
                type="text"
                className="w-[162px] h-[52px] rounded-lg border border-[#E7E7E9] px-4 text-[14px] text-[#3D3F50] bg-white font-roboto"
                value={startDate}
                placeholder="YYYY/MM/DD"
                onChange={e => setStartDate(e.target.value)}
              />
              <IoCalendarOutline className="absolute top-1/2 right-3 -translate-y-1/2 text-xl text-[#3D3F50]" />
            </div>
          </div>
          <div>
            <label className="block text-[14px] text-[#3D3F50] mb-1">End Date</label>
            <div className="relative">
              <input
                type="text"
                className="w-[162px] h-[52px] rounded-lg border border-[#E7E7E9] px-4 text-[14px] text-[#858791] bg-white font-roboto"
                value={endDate}
                placeholder="YYYY/MM/DD"
                onChange={e => setEndDate(e.target.value)}
              />
              <IoCalendarOutline className="absolute top-1/2 right-3 -translate-y-1/2 text-xl text-[#3D3F50]" />
            </div>
          </div>
        </div>
      </div>
      <hr className="border-[#E7E7E9] mb-4" />
      {/* By Type & Milestone */}
      <div className="mb-6">
        <span className="text-[16px] font-semibold text-[#3D3F50] block mb-2">By Type & Milestone</span>
        <Collapsible
          label="Information"
          checked={checked.info}
          onCheck={handleParentCheck("info")}
        >
          <Checkbox
            label="Transaction Payment"
            checked={checked.infoItems["Transaction Payment"] || false}
            onChange={handleChildCheck("info", "Transaction Payment")}
          />
          <Checkbox
            label="Transaction Status"
            checked={checked.infoItems["Transaction Status"] || false}
            onChange={handleChildCheck("info", "Transaction Status")}
          />
          <Checkbox
            label="Invoice"
            checked={checked.infoItems["Invoice"] || false}
            onChange={handleChildCheck("info", "Invoice")}
          />
          <Checkbox
            label="Invoice Paid"
            checked={checked.infoItems["Invoice Paid"] || false}
            onChange={handleChildCheck("info", "Invoice Paid")}
          />
          <Checkbox
            label="Payment"
            checked={checked.infoItems["Payment"] || false}
            onChange={handleChildCheck("info", "Payment")}
          />
        </Collapsible>
        <Collapsible
          label="Action Required"
          checked={checked.action}
          onCheck={handleParentCheck("action")}
        >
          <Checkbox
            label="Draft DA"
            checked={checked.actionItems["Draft DA"] || false}
            onChange={handleChildCheck("action", "Draft DA")}
          />
          <Checkbox
            label="Transaction Status"
            checked={checked.actionItems["Transaction Status"] || false}
            onChange={handleChildCheck("action", "Transaction Status")}
          />
          <Checkbox
            label="Invoice"
            checked={checked.actionItems["Invoice"] || false}
            onChange={handleChildCheck("action", "Invoice")}
          />
        </Collapsible>
        <Collapsible
          label="Recognition"
          checked={checked.recog}
          onCheck={handleParentCheck("recog")}
        >
          <Checkbox
            label="First Transaction"
            checked={checked.recogItems["First Transaction"] || false}
            onChange={handleChildCheck("recog", "First Transaction")}
          />
        </Collapsible>
      </div>
      <button className="w-full mt-4 h-10 bg-[#1B489B] text-white font-roboto rounded-lg text-[18px] font-normal shadow hover:bg-[#163d7a] transition-all">
        Apply
      </button>
    </div>
  );
}



Code - Mobile

import React, { useState } from "react";

const OPTIONS = [
  "Option 1",
  "Option 2",
  "Option 3",
  "Option 4",
  "Option 5",
  "Option 6",
];

export default function MobileFiltersSheet() {
  // Options 5 & 6 are checked initially (indexes 4,5)
  const [checked, setChecked] = useState([false, false, false, false, true, true]);
  function handleCheck(idx) {
    setChecked(arr => arr.map((v, i) => i === idx ? !v : v));
  }
  function handleReset() {
    setChecked([false, false, false, false, false, false]);
  }

  return (
    <div className="w-[375px] min-h-[491px] font-['Roboto'] text-[#303030]">
      {/* Drag area + Panel */}
      <div className="rounded-t-[20px] bg-white flex flex-col items-center pt-5 pb-2 relative">
        {/* drag indicator */}
        <div className="w-[50px] h-[3px] rounded-full bg-[#A3A4A7]/[.2] mb-6"/>
        {/* Header row */}
        <div className="flex items-center justify-between w-[335px] mb-5">
          <span className="font-bold text-xl text-[#0C0F24]">Filter</span>
          {/* close (X) */}
          <button tabIndex={0} aria-label="Close">
            <svg width="24" height="24">
              <line x1="6" y1="6" x2="18" y2="18" stroke="#303030" strokeWidth="2"/>
              <line x1="18" y1="6" x2="6" y2="18" stroke="#303030" strokeWidth="2"/>
            </svg>
          </button>
        </div>
        <div className="w-[335px] h-[1.13px] bg-[#303030]/[.05] mb-6"/>
        {/* Options */}
        <div className="w-[335px] flex flex-col gap-4 mb-8">
          {OPTIONS.map((label, idx) => (
            <label key={label} className="flex items-center gap-2 cursor-pointer select-none text-[22px]">
              {/* Checkbox */}
              <span
                className={`flex items-center justify-center w-8 h-8 rounded-md border
                  ${
                    checked[idx]
                      ? "bg-[#153A83] border-[#153A83]"
                      : "border-[#0C0F24] bg-white"
                  }`}
                onClick={() => handleCheck(idx)}
                tabIndex={0}
                role="checkbox"
                aria-checked={checked[idx]}
              >
                {checked[idx] && (
                  <svg width="20" height="20" viewBox="0 0 16 16">
                    <polyline
                      points="4,9 7,12 12,5"
                      fill="none"
                      stroke="#fff"
                      strokeWidth="2.1"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    />
                  </svg>
                )}
              </span>
              <span className="text-[28px] font-normal text-[#303030]">{label}</span>
            </label>
          ))}
        </div>
        {/* Action buttons */}
        <div className="w-[335px] flex flex-row gap-3 mb-7">
          <button
            className="flex-1 h-10 border border-[#153A83] rounded-lg flex items-center justify-center text-[28px] font-normal text-[#153A83] bg-white"
            onClick={handleReset}
          >
            Reset
          </button>
          <button
            className="flex-1 h-10 rounded-lg flex items-center justify-center text-[28px] font-normal text-white bg-[#153A83]"
            // onClick...
          >
            Apply
          </button>
        </div>
        {/* Home indicator */}
        <div className="absolute left-1/2 -translate-x-1/2 bottom-2 w-[134px] h-[5px] rounded-full bg-black" />
      </div>
    </div>
  );
}
Code - Web

import React, { useState } from "react";

const OPTIONS = [
  "Option 1",
  "Option 2",
  "Option 3",
  "Option 4",
  "Option 5",
  "Option 6",
];

export default function LovableFilterWeb() {
  const [popup, setPopup] = useState(false);
  const [checked, setChecked] = useState([false, false, true, true, false, false]); // match image
  function handleCheck(idx) {
    setChecked(arr => arr.map((v, i) => (i === idx ? !v : v)));
  }
  function handleReset() {
    setChecked([false, false, false, false, false, false]);
  }

  // Filter button (as per design)
  function FilterButton({ onClick }) {
    return (
      <button
        className="flex items-center border border-[#1B489B] rounded-[6px] px-4 h-10 gap-2 bg-white min-w-[132px] hover:bg-[#F5F8FC] transition-all"
        onClick={onClick}
      >
        {/* Filter icon */}
        <svg width="24" height="24" fill="none">
          <rect x="6" y="3" width="12" height="2" rx="1" stroke="#1B489B" strokeWidth="1.5"/>
          <rect x="3" y="8" width="18" height="2" rx="1" stroke="#1B489B" strokeWidth="1.5"/>
          <rect x="8" y="13" width="8" height="2" rx="1" stroke="#1B489B" strokeWidth="1.5"/>
        </svg>
        <span className="text-[#1B489B] font-normal text-[20px]">Filter</span>
        {/* right arrow */}
        <svg width="24" height="24">
          <polyline points="9,7 15,12 9,17" fill="none" stroke="#1B489B" strokeWidth="2" strokeLinecap="round"/>
        </svg>
      </button>
    );
  }

  return (
    <div className="w-[588px] h-[525px] relative font-['Roboto']">
      {/* Option label */}
      <div className="text-[20px] font-normal text-[#303030] ml-1 mb-2">Option 1</div>
      {/* Filter buttons */}
      <div className="flex gap-5 ml-1 mt-4">
        <FilterButton onClick={() => setPopup(true)} />
        <FilterButton onClick={() => setPopup(true)} />
      </div>
      {/* Popover (sheet) */}
      {popup && (
        <div className="fixed z-50 left-[175px] top-[65px] w-[375px] bg-white rounded-[20px] shadow-[0_4px_16px_rgba(48,48,48,0.2)] p-5 border border-[#ECECEC] animate-fade-in">
          {/* Header */}
          <div className="flex justify-between items-center mb-4">
            <span className="font-bold text-[24px] text-[#0C0F24]">Filter</span>
            <button onClick={() => setPopup(false)} tabIndex={0} aria-label="Close">
              <svg width="32" height="32">
                <line x1="9" y1="9" x2="23" y2="23" stroke="#303030" strokeWidth="2"/>
                <line x1="23" y1="9" x2="9" y2="23" stroke="#303030" strokeWidth="2"/>
              </svg>
            </button>
          </div>
          <div className="w-full h-[1.13px] bg-[#303030]/[.05] mb-5" />
          {/* Options */}
          <div className="flex flex-col gap-5 mb-8">
            {OPTIONS.map((label, idx) => (
              <label key={label} className="flex items-center gap-3 cursor-pointer select-none text-[20px]">
                {/* Checkbox */}
                <span
                  className={`flex items-center justify-center w-6 h-6 rounded-md border
                    ${
                      checked[idx]
                        ? "bg-[#1B489B] border-[#1B489B]"
                        : "border-[#0C0F24] bg-white"
                    }`}
                  onClick={() => handleCheck(idx)}
                  tabIndex={0}
                  role="checkbox"
                  aria-checked={checked[idx]}
                >
                  {checked[idx] && (
                    <svg width="18" height="18" viewBox="0 0 16 16">
                      <polyline
                        points="4,9 7,12 12,5"
                        fill="none"
                        stroke="#fff"
                        strokeWidth="2.1"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      />
                    </svg>
                  )}
                </span>
                <span className="text-[22px] text-[#303030]">{label}</span>
              </label>
            ))}
          </div>
          {/* Actions */}
          <div className="flex gap-3 w-full">
            <button
              className="flex-1 h-10 border border-[#1B489B] rounded-lg flex items-center justify-center text-[22px] text-[#1B489B] bg-white"
              onClick={handleReset}
            >
              Reset
            </button>
            <button
              className="flex-1 h-10 rounded-lg flex items-center justify-center text-[22px] text-white bg-[#153A83]"
            >
              Apply
            </button>
          </div>
        </div>
      )}
    </div>
  );
}



Purpose
Filters enable users to refine search results or data views by applying specific criteria. They support quick navigation and personalized content, adapting to both mobile and web layouts.

Principles
Simplicity: Use clear labels and actionable buttons. Options should be intuitive and easy to scan.


Accessibility: Ensure high-contrast selection states and make all filter options easy to tap or click.


Consistency: Maintain similar visual and interaction patterns for filters across mobile and web.


Usability: Actions like apply/reset should be smooth and not disrupt user flow.



Anatomy
Filter Icon: Universally recognized symbol to indicate where filters can be found.


Filter Options: Typically presented as checkboxes, date pickers, or other selectors.


Reset Button: Clears all filters and returns to the default view.


Apply Button: Confirms and applies the selected filters.


Close Button (X): Dismisses the filter panel without changes.



Layout Types
Mobile Filter: Compact, vertical layout with stacked options and clear action buttons for smaller screens.


Web Filter: Dropdown or popover panels, with:


Option 1: Checkbox lists for multiple choices.


Option 2: Predefined quick-selects (e.g., “YTD”, “MTD”) and custom date range selectors.



Usage Guidelines
Clear Labels: Each option and section must have a clear, descriptive label.


Easy Selection: Users must be able to check, uncheck, or pick options with clear feedback.


Visible Actions: “Reset” and “Apply” buttons should be easily accessible and always visible at the bottom of the panel.


Dismissal: Always allow users to close without applying changes, especially on accidental taps/clicks.


Responsive: Filter panels should be scrollable if there are many options, and adapt gracefully to screen sizes.



Accessibility
Provide keyboard navigation and focus states for all filter controls.


Ensure text and icons have sufficient color contrast.


Use ARIA labels and roles if building with code.



Microcopy Suggestions
Labels: Use plain, action-oriented text (“Filter by status”, “Date range”).


Empty State: “No options found. Try adjusting your filters.”


Buttons: “Apply filters”, “Reset all”, “Close”



Figma Tips
Build filters as components with variants for:


Selected/unselected options


Disabled state


Default/active/hover/focus


Use auto layout for mobile panels and web popovers.


Group filter actions at the panel’s footer with proper spacing.

Modals – Lovable Design System
Purpose
Modals are temporary overlay components used to capture the user’s attention and prompt for critical actions—such as confirmations, alerts, or short forms—without navigating away from the current page.

Anatomy
Overlay/Background: Semi-transparent layer to dim content and focus attention.


Modal Container: Centered box for modal content.


Header (optional): Title or purpose of the modal.


Body: Main content (info, forms, alerts, illustrations).


Footer (optional): Action buttons (e.g., “Confirm”, “Cancel”).


Close Button: “X” or similar icon in a consistent top corner.



Types of Modals
Standard Modal: Title, content, actions (e.g., “Save”, “Cancel”).


Confirmation Modal: Prompts user to confirm/cancel an action.


Alert Modal: Single message with “Okay” or “Acknowledge”.


Form Modal: For quick input; not for complex multi-step flows.



Usage Guidelines
Use for critical, focused interactions that require the user’s immediate attention.


Avoid using modals for non-essential or bulk information.


Interaction:


Must be dismissible (close button, ESC key, click outside).


Return keyboard focus to the triggering element on close.


All modal controls must be keyboard accessible.



Visual Design
Overlay: rgba(0,0,0,0.5) or similar.


Container: Solid background, soft shadow, clear contrast.


Padding: Spacious, comfortable.


Borders: Rounded corners for a modern, lovable feel.


Buttons: Clear, action-oriented (e.g., “Save”, “Delete”), never ambiguous (“Yes”).



Dos
Use sparingly for important tasks only.


Keep content concise and focused.


Allow easy dismissal.


Clearly label action buttons.



Don’ts
Don’t use for non-essential info.


Don’t place complex/multi-step forms in modals unless unavoidable.


Don’t forget keyboard and focus management for accessibility.



Microcopy Tips
Titles: “Are you sure?”, “Delete payment method?”, “Success!”


Actions: “Confirm”, “Cancel”, “Got it”, “Try again”


Body: Briefly explain the action or consequence.



Figma Tips
Make modals as reusable components with variants (e.g., confirmation, alert, form).


Use auto layout for easy padding adjustments.


Add focus outlines to all interactive elements.
Side Panel & Bottom Sheet – Lovable Design System
Overview
Side Panels (web) and Bottom Sheets (mobile) are overlay components for providing users with additional content or actions without overwhelming the main screen. They optimize screen space, maintain a seamless experience, and prevent context loss by keeping users anchored to their current view.

Principles
Simplicity & Clarity:


Show only essential actions or information.


Avoid overloading users with options.


Prioritize high-contrast, legible text, and clear visual cues.


Consistency:


Match the overall product design system—typography, spacing, icons, and buttons.


Visibility & Accessibility:


Panels/sheets must be obvious and easy to access/close.


Always use clear visual indicators (labels, icons, close buttons, swipes).


Provide full keyboard and screen reader support.


Minimal Disruption:


Present only what’s relevant for the current task.


Avoid blocking essential information in the main content area.


Responsiveness:


Adapt layout and controls to fit various screen sizes and orientations.


Clear Interaction Feedback:


Provide immediate visual cues (swipe areas, focus rings, hover states).


Ease of Dismissal:


Users should be able to close panels easily via a close button, tap outside, swipe, or ESC key.



Anatomy
Side Panel (Web)
Overlay: Dim background, closes panel when tapped/clicked.


Container: Slides in from left or right; width varies by breakpoint (e.g., 480px for compact, 600px for wide).


Header: Title and optional close (“X”) icon.


Content: Navigation, settings, forms, info, contextual actions.


Footer: Actions such as “Save,” “Cancel,” or secondary buttons.


Bottom Sheet (Mobile)
Overlay: Dim background, closes on tap or swipe down.


Panel: Slides up from the bottom; height varies based on content (30–60% of screen, or expandable).


Header: Drag handle (optional), title, close (“X”).


Body: Actions, forms, or lists.


Footer: Primary/secondary action buttons.



Usage
Use when users need to complete actions without losing their current page.


Panels/sheets can be dismissed by:


Tap outside area


Swipe down (bottom sheet)


Click close (“X”)


ESC key


Avoid placing multi-step flows or complex forms in panels unless necessary.



Design Guidelines
Side Panels (Web):


Optimize for both narrow and wide widths.


Maintain generous padding and legible font sizes.


Use consistent iconography for actions.


Bottom Sheets (Mobile):


Keep content minimal and focused.


Large, clear buttons for primary actions (min 48x48px).


Logical tab order and clear focus outlines.



Dos
Do: Maintain visual hierarchy—title, actions, content.


Do: Use smooth open/close animations.


Do: Provide clear dismissal controls.


Do: Test for accessibility—keyboard, mouse, and screen reader support.


Don’ts
Don’t overload with content.


Don’t block key content in the main view.


Don’t require complex gestures or multiple steps to dismiss.


Don’t break design consistency with the rest of the system.



Figma Tips
Build panels and bottom sheets as components with variants (e.g., with/without header, with/without footer).


Use auto layout for flexible padding and responsive resizing.


Include focus ring and hover/active states for all interactive elements.


Add overlays as separate layers in Figma for easier prototyping.



Accessibility
All actions must be reachable by keyboard.


Trap focus within the panel/sheet until dismissed.


Return focus to the triggering element on close.


Use aria-labels, roles, and semantic headings for screen readers.


Ensure sufficient color contrast for overlays and controls.



Microcopy
Headings: “Settings,” “Confirm Change,” “Add Payment Method”


Actions: “Save,” “Cancel,” “Send Code,” “Dismiss”


Body: Keep instructions clear and concise (“Choose your notification preferences below.”)
Infographics – Lovable Design System
Info
Infographics are visual representations of data, information, or knowledge. As components within a design system, infographics help communicate key metrics, trends, and insights visually—making complex information easy to digest at a glance. Use them for dashboards, reports, data visualizations, and anywhere users need to understand data quickly and effectively.

Principles
Clarity:


Information must be simple and instantly understandable.


Avoid visual clutter and unnecessary decorative elements.


Accuracy:


Only present verified, up-to-date information.


Double-check data sources and chart calculations.


Consistency:


Use brand fonts, colors, and iconography that align with the design system.


Consistent chart and legend styling.


Hierarchy:


Make key insights and data points visually prominent.


Use size, color, or placement to direct user attention.


Simplicity:


Use only as much detail as needed for comprehension—no more.


Contextual Relevance:


Show information meaningful to the user’s goals and context.


Interactivity (if applicable):


Ensure interactive areas are visually clear (e.g., hover/focus states, clickable legends).


Use tooltips for deeper insight without cluttering the visual.


Responsiveness:


Scale cleanly for mobile, tablet, and desktop.


Avoid overcrowding or unreadable elements on smaller screens.



Anatomy
Title/Label: What does this infographic show? Use a short, descriptive label.


Data Visualizations:


Use appropriate chart types (pie, bar, line, etc.), icons, and numbers.


Annotations/Legends:


Provide context, explanations, or clarify color and symbol meaning.


Color Scheme:


Brand-aligned and colorblind-accessible.


Max 4–6 colors per infographic to avoid confusion.


Data Source (if needed):


Show where the information comes from (e.g., “Source: Internal analytics”).


Callout Sections:


Highlight key data points or trends—use different shapes/colors if needed.


Interactive Elements (optional):


Tooltips, dropdowns, or clickable segments—provide clear feedback on hover/tap.



Usage
Use for summarizing complex data in a simple, visual way:


Dashboards, real-time metrics, KPI summaries


Performance overviews


Reports and presentations


“Empty state” explanations (e.g., “No data yet” with a chart or progress donut)


Infographics should not replace detailed tables, but complement them for quick scanning and insight.


Always pair with clear labels and supporting text as needed.


Avoid presenting misleading or incomplete data.



Design Guidelines
Typography:
Use clear, legible fonts—never decorative.


Limit font weights/sizes for clarity and hierarchy.


Color Usage:
Use accessible, contrasting colors for categories and data sets.


Avoid more than 4–6 colors per chart for clarity.


Never use color alone to distinguish information—support with labels, icons, or patterns.


Spacing & Alignment:
Ensure even spacing and alignment for a clean, organized layout.


Avoid overlapping elements, especially on mobile.


Icons & Visual Elements:
Use icons only to support understanding.


All icons must be meaningful and consistent with the design system.


Responsive Design:
Test infographics on all screen sizes. Components should reflow or stack as needed.


Interactivity:
Use visible cues (hover, focus ring, underline) for interactive areas.


Always provide alt text and ARIA labels for screen readers.



Dos & Don’ts
Dos:
Keep the design clean—focus on essential information.


Use clear labels/titles for every chart or infographic.


Ensure accessibility with alt text and readable fonts.


Use consistent color schemes and typographic hierarchy.


Make sure infographics scale for all devices.


Don’ts:
Don’t overload with data points or legends.


Don’t use too many colors, or colors with low contrast.


Don’t mislead—only use accurate, up-to-date data.


Don’t hide the most important information—use visual hierarchy!


Don’t make infographics too large or too small for the viewport.



Figma Implementation Tips
Build as variants—include versions for mobile, tablet, and desktop.


Use Figma Auto Layout for flexible resizing and spacing.


Add annotation and legend components as reusable elements.


Include color styles and text styles from your Lovable design tokens.


Add notes for accessibility: “Always add alt text/ARIA for charts and icons.”



Microcopy
Use clear, action-oriented labels:


“Revenue Share”


“Total Users”


“KPI Trends”


“No data available”


Tooltips: “Click to explore breakdown”
Calendars – Lovable Design System
Info
The Calendar component enables users to select dates or navigate through months and years quickly. It’s designed for clean, responsive, and accessible date selection—perfect for forms, filters, and reports.

Principles
Clarity:


Use clear labels for months, days, and years.


The current selection should always be visually obvious.


Accessibility:


Fully support keyboard navigation, ARIA roles, and screen readers.


Efficiency:


Allow rapid navigation between months and years with minimal effort (e.g., direct year/month selection).


Consistency:


Match the design system’s typography, colors, and spacing.


Responsiveness:


Adapt to all screen sizes without losing usability or clarity.



Anatomy
Header: Month/year selector, navigation arrows.


Day Grid: Clearly labeled rows for weeks, columns for days.


Selected/Today State: Distinct visual styles for selected day and today.


Range/Multiple Selection (if supported): Show clear start, end, and in-between states.


Footer/Action Buttons: For “Apply”, “Cancel”, etc., as needed.



Usage
Date selection in forms: Booking, scheduling, filtering, etc.


Range selection (if supported): For reports, analytics, or custom queries.


Year/month quick-pick: Let users change years or months with a tap/click.



Design Guidelines
Typography
Use clean, legible fonts—avoid decorative or script fonts.


Font size should differentiate between header, days, and supporting text for hierarchy.


Color Usage
Use accessible, high-contrast color palettes.


Stick to a limited palette—use color (plus iconography or borders) to indicate selection, today, or disabled dates.


Spacing & Alignment
Maintain even grid spacing for dates.


Keep navigation and action buttons visually aligned for quick scanning.


Icons & Visual Elements
Use clear arrow icons for navigation.


Highlight selected date and today’s date with strong, but not overwhelming, visuals.


Responsive Design
Ensure the calendar resizes and remains usable on all screen sizes.


Consider stacked layouts or pop-over modals on mobile.


Interactivity
Provide clear hover/focus states for every clickable element.


Always support keyboard navigation: Tab, arrow keys, Enter/Esc.


Announce changes via ARIA live regions if necessary.



Dos & Don’ts
Dos
Keep the layout clean and simple.


Label all navigation, days, months, and years.


Use consistent colors and typography.


Support accessibility for all users.


Clearly indicate current selection, today, and disabled dates.


Don’ts
Don’t overload with unnecessary features or details.


Don’t use color alone for meaning—combine with icons or text.


Don’t present misleading or out-of-date information.


Don’t make the calendar too large or small to fit its container.



Microcopy
Month/Year selectors: “Select Month”, “Select Year”


Action buttons: “Apply”, “Cancel”, “Done”


Tooltips for disabled dates: “Date unavailable”, “Outside valid range”



Figma tips:
Use Auto Layout for grid and header/footer.


Build variants for different states (default, selected, today, disabled).


Use design tokens for colors, spacing, and typography.


OTP (One-Time Password) – Lovable Design System

Code

import React from "react";
import clsx from "clsx";

const OTP_SIZES = {
  base: {
    box: "w-[52px] h-[52px] rounded-[7px] border border-[#858791] bg-white text-[32px]",
    gap: "gap-[12px]",
  },
  sm: {
    box: "w-[48px] h-[48px] rounded-[7px] border border-[#858791] bg-white text-[28px]",
    gap: "gap-[12px]",
  },
};

export function OtpInput({
  digits = 4,           // 4 or 6
  size = "base",        // 'base' | 'sm'
  label = "Label",
  subtext = "Secondary text",
  value,
  onChange,
}) {
  // Split value into individual boxes, enforce max length, support keyboard input
  const boxes = Array.from({ length: digits }, (_, i) => value[i] || "");
  const inputRefs = React.useRef([]);

  // Handle input, move focus automatically
  const handleInput = (e, idx) => {
    const val = e.target.value.replace(/[^0-9a-zA-Z]/, "");
    let newValue = value.split("");
    newValue[idx] = val[0] || "";
    onChange(newValue.join("").slice(0, digits));
    if (val && idx < digits - 1) {
      inputRefs.current[idx + 1]?.focus();
    }
  };

  // Handle backspace to move left
  const handleKeyDown = (e, idx) => {
    if (e.key === "Backspace" && !boxes[idx] && idx > 0) {
      inputRefs.current[idx - 1]?.focus();
    }
  };

  const { box, gap } = OTP_SIZES[size];

  return (
    <div className="flex flex-col items-start gap-2 mb-5">
      <label className="text-[16px] font-roboto font-normal text-[#0C0F24] mb-1">
        {label}
      </label>
      <div className={clsx("flex flex-row", gap)}>
        {boxes.map((val, i) => (
          <input
            key={i}
            type="text"
            maxLength={1}
            className={clsx(box, "text-center outline-none focus:border-[#9747FF]")}
            value={val}
            onChange={e => handleInput(e, i)}
            onKeyDown={e => handleKeyDown(e, i)}
            ref={el => (inputRefs.current[i] = el)}
            inputMode="numeric"
            autoComplete="one-time-code"
          />
        ))}
      </div>
      <span className="text-[12px] leading-[18px] font-roboto text-[#0C0F24] mt-1">
        {subtext}
      </span>
    </div>
  );
}


Principles
Clarity:
 Make input fields visually prominent and clearly labeled.


Focus Management:
 Auto-focus moves to the next input after valid entry; allow backspace to move focus back.


Error Handling:
 Provide clear, real-time feedback for incorrect, incomplete, or missing inputs—never rely on color alone.


Accessibility:
 Fully support keyboard navigation, numeric keypad entry, and screen readers.


Consistency:
 Align spacing, type, and colors with the rest of the design system.



Anatomy
Individual Input Boxes: One box per character, evenly spaced.


Pre-focus: Place focus on the first box by default.


Auto-advance: Move focus to next box after entry.


Backspace: Allows focus to move back if character is deleted.


Active State: Highlighted border or indicator on the focused box.


Error State: Error color or border, with icon or message for incorrect/incomplete input.



Usage
Authentication: Login, sign-up, password reset, MFA, secure actions.


Verification: Transaction approvals, sensitive changes.



Design Guidelines
Use a clear label (e.g., “Enter the 6-digit code sent to your email.”)


Provide immediate validation per input box (with visual, textual, or icon feedback).


Show a countdown timer and clear “resend code” action.


Keep navigation and interactions (tab, backspace) intuitive.


Ensure input fields are accessible, keyboard and mobile friendly.



Dos
Pre-focus the first input box.


Move automatically to next box after valid character.


Allow backspace to clear the current and previous box.


Use clear error messages (“Invalid code. Try again.”) with supporting icons if possible.


Show countdown for resend action.


Support both keyboard and on-screen numeric keypad.


Keep interactions simple and predictable.


Don’ts
Don’t auto-submit before all digits are entered.


Don’t use generic error messages; always explain what’s wrong.


Don’t rely only on color for error—use icons and text.


Don’t overwhelm with retry attempts or confusing UI.



Microcopy
Labels: “Enter Verification Code”, “Enter the 6-digit code sent to your phone/email”


Error: “Invalid code. Please try again.”


Helper: “We sent a code to ***@domain.com. Resend code in 00:30.”



Figma tips:
Use Auto Layout for the input row.


Use variants for normal, focused, error, and filled states.


Support keyboard tab, shift+tab, and backspace.


Let me know if you want an example Figma layer structure or microcopy suggestions for empty, error, and success states!
Page Summary: OTP Component – Lovable Design System
Sections Present:
Info:
 Describes the purpose: secure authentication/verification with short codes (typically 4–6 digits) from various channels, designed for clarity, usability, and speed.


Principles:


Clarity — Prominent, easy to navigate input fields


Focus Management — Auto-moves focus, efficient flow


Error Handling — Clear feedback for invalid/incomplete entries


Accessibility — Keyboard, screen reader, adaptive technologies


Consistency — Matches spacing, typography, color, etc. across the design system


Anatomy:


Separate input boxes per character


Auto-focus to next box after valid entry


Error indicator: highlight boxes with error styling


Active state: highlighted current box


Usage:


Authentication (login, signup)


Password resets, sensitive actions


Multi-factor authentication (MFA)


Transactional verifications


Design Guidelines:


Pre-focus first box on open


Auto-move focus after valid entry


Allow backspace to move focus back


Show real-time validation


Show countdown timer for resend


Support keyboard/numeric keypad


Dos and Don’ts:


Dos: Use clear label, validate per box, show countdown, intuitive navigation, support various input methods


Don’ts: Don’t auto-submit too early, don’t use generic or color-only errors, don’t overwhelm users with many retry attempts


Microcopy:
 (Section present, but content is not filled in.)


List Items

Code

import React, { useState } from "react";

function Switch({ checked, onChange }) {
  return (
    <button
      onClick={onChange}
      className={`
        w-12 h-6 rounded-full flex items-center
        transition-colors
        ${checked ? "bg-[#1B489B]" : "bg-gray-300"}
      `}
      style={{ minWidth: 48 }}
      aria-checked={checked}
      role="switch"
    >
      <span
        className={`
          inline-block h-[22px] w-[22px] rounded-full bg-white shadow transition-all
          ${checked ? "translate-x-6" : "translate-x-1"}
        `}
        style={{
          transition: "transform 0.2s",
        }}
      />
    </button>
  );
}

export default function LovableListItemDemo() {
  const [checked1, setChecked1] = useState(true);
  const [checked2, setChecked2] = useState(true);

  return (
    <div className="w-[480px] h-[432px] border border-dashed border-[#9747FF] rounded-[5px] p-0 font-['Roboto'] bg-black/0">
      {/* 1st item: X icon */}
      <div className="flex flex-row items-start p-3.5 gap-4 w-[440px] h-[116px] bg-white mx-5 mt-5 mb-4 rounded">
        <div className="flex flex-col justify-center items-center w-[40px] h-[92px]">
          {/* Big X svg */}
          <svg width={55} height={50}>
            <line x1="10" y1="10" x2="45" y2="40" stroke="#070707" strokeWidth="6"/>
            <line x1="45" y1="10" x2="10" y2="40" stroke="#070707" strokeWidth="6"/>
          </svg>
        </div>
        <div className="flex flex-col flex-1 gap-1">
          <span className="text-[#858791] text-[18px] leading-5 font-normal">OVERLINE</span>
          <span className="text-[#0C0F24] text-[28px] leading-6 font-normal">List Item</span>
          <span className="text-[#858791] text-[20px] leading-6 font-normal">
            Supporting line text lorem ipsum dolor sit amet, consectetur.
          </span>
        </div>
        <div className="flex items-center h-full">
          <Switch checked={checked1} onChange={() => setChecked1(!checked1)} />
        </div>
      </div>

      {/* 2nd item: Thumbnail */}
      <div className="flex flex-row items-start p-3.5 gap-4 w-[440px] h-[116px] bg-white mx-5 mb-4 rounded">
        <img
          src="https://images.unsplash.com/photo-1506744038136-46273834b3fb?auto=format&fit=facearea&w=64&h=64&q=80"
          className="w-[44px] h-[44px] rounded-[1px] object-cover"
          alt="thumbnail"
        />
        <div className="flex flex-col flex-1 gap-1">
          <span className="text-[#858791] text-[18px] leading-5 font-normal">OVERLINE</span>
          <span className="text-[#0C0F24] text-[28px] leading-6 font-normal">List Item</span>
          <span className="text-[#858791] text-[20px] leading-6 font-normal">
            Supporting line text lorem ipsum dolor sit amet, consectetur.
          </span>
        </div>
        <div className="flex items-center h-full">
          <Switch checked={checked2} onChange={() => setChecked2(!checked2)} />
        </div>
      </div>

      {/* 3rd item: Text only, check at right */}
      <div className="flex flex-row items-start p-3.5 gap-4 w-[440px] h-[116px] bg-white mx-5 mb-2 rounded">
        <div className="flex flex-col flex-1 gap-1">
          <span className="text-[#858791] text-[18px] leading-5 font-normal">OVERLINE</span>
          <span className="text-[#0C0F24] text-[28px] leading-6 font-normal">List Item</span>
          <span className="text-[#858791] text-[20px] leading-6 font-normal">
            Supporting line text lorem ipsum dolor sit amet, consectetur.
          </span>
        </div>
        <div className="flex items-end h-full">
          <svg width="34" height="34" viewBox="0 0 24 24">
            <polyline
              points="6,13 11,18 19,8"
              fill="none"
              stroke="#070707"
              strokeWidth="3"
              strokeLinecap="round"
              strokeLinejoin="round"
            />
          </svg>
        </div>
      </div>
    </div>
  );
}










